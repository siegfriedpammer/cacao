diff -u compress1/Compress.java compress/Compress.java
--- compress1/Compress.java	Wed Jun 17 22:14:24 1998
+++ compress/Compress.java	Fri Oct 25 11:47:20 2002
@@ -1,15 +1,4 @@
 /*
- *  Used 'Inner Classes' to minimize temptations of JVM exploiting low hanging
- *  fruits. 'Inner classes' are defined in appendix D of the 'Java Programming
- *  Language' by Ken Arnold.
- *  - We moved the class declaration, unchanged, of Hash_Table to within the
- *    class declaration of Compressor.
- *  - We moved the class declarations, unchanged, of De_Stack and
-      Suffix_Table to within the class declaration of Decompressor.
- *  - pre-computed trivial htab(i) to minimize millions of trivial calls
- *  - Don McCauley (IBM), Kaivalya 4/16/98
- *
- *   @(#)Compress.java	1.7 06/17/98
  *  // Don McCauley/kmd  - IBM 02/26/98
  *  // getbyte and getcode fixed -- kaivalya & Don
  * compress.c - File compression ala IEEE Computer, June 1984.
@@ -29,12 +18,8 @@
  * substrings and replaces them with a variable size code.  This is
  * deterministic, and can be done on the fly.  Thus, the decompression
  * procedure needs no input table, but tracks the way the table was built.
- *
- * This source code is provided as is, without any express or implied warranty.
  */
 
-package spec.benchmarks._201_compress;
-
 final class Compress {
     final static int BITS = 16;		/* always set to 16 for SPEC95 */
     final static int INIT_BITS = 9;	/* initial number of bits/code */
@@ -162,6 +147,39 @@
 
 /*****************************************************************/
 
+final class Hash_Table {
+    private int tab[];
+    private int size;			/* for dynamic table sizing */
+
+    public Hash_Table() {
+	size = Compress.HSIZE;
+	tab = new int[size];
+    }
+
+    public int of(int i) {
+	return tab[i];
+    }
+
+    public void set(int i, int v) {
+	tab[i] = v;
+    }
+
+    public int hsize() {
+	return size;
+    }
+
+    public void clear() {
+	int i;
+
+	for (i = 0; i < size; i++) {
+	    tab[i] = -1;
+	}
+    }
+};
+
+
+/*****************************************************************/
+
 final class Code_Table {
     private short tab[];
 
@@ -188,6 +206,58 @@
 
 /*****************************************************************/
 
+final class Suffix_Table {
+    private byte tab[];
+
+    public Suffix_Table () {
+	tab = new byte[Compress.SUFFIX_TAB_SZ];
+    }
+
+    public byte of(int i) {
+	return tab[i];
+    }
+
+    public void set(int i, byte v) {
+	tab[i] = v;
+    }
+
+    public void init(int size) {
+	int code;
+	for ( code = 0; code < size; code++ ) {
+	    tab[code] = (byte)code;
+	}
+    }
+};
+
+
+/*****************************************************************/
+
+final class De_Stack {
+    private byte tab[];
+    private int index;
+
+    public De_Stack() {
+	tab = new byte[Compress.STACK_SZ];
+	index = 0;
+    }
+
+    public void push(byte c) {
+	tab[index++] = c;
+    }
+
+    public byte pop() {
+	index--;
+	return tab[index];
+    }
+
+    public boolean is_empty() {
+	return (index == 0);
+    }
+};
+
+
+/*****************************************************************/
+
 class Comp_Base {
     protected int n_bits;		/* number of bits/code */
     protected int maxbits;		/* user settable max # bits/code */
@@ -264,7 +334,7 @@
 	checkpoint = CHECK_GAP;
 	free_ent = ((block_compress != 0) ? Compress.FIRST : 256 );
 
-	htab = new Hash_Table();  // dm/kmd 4/10/98
+	htab = new Hash_Table();
 	codetab = new Code_Table();
 
 	Output.putbyte(Compress.magic_header[0]);
@@ -296,15 +366,13 @@
 	    in_count++;
 	    fcode = (((int) c << maxbits) + ent);
   	    i = ((c << hshift) ^ ent);	/* xor hashing */
-            int temphtab = htab.of (i);  // dm/kmd 4/15
-//dm kmd	    if ( htab.of (i) == fcode ) {  // dm/kmd 4/15
-	    if ( temphtab == fcode ) {
+
+	    if ( htab.of (i) == fcode ) {
 		ent = codetab.of (i);
 		continue next_byte;
 	    }
 
-//dm kmd 4/15	    if ( htab.of (i) >= 0 ) {	/* non-empty slot */
-	    if ( temphtab >= 0 ) {	/* non-empty slot  dm kmd 4/15*/
+	    if ( htab.of (i) >= 0 ) {	/* non-empty slot */
 		disp = hsize_reg - i;	/* secondary hash (after G. Knott) */
 		if ( i == 0 )
 		    disp = 1;
@@ -313,15 +381,11 @@
 		    if ( (i -= disp) < 0 )
 			i += hsize_reg;
 
-                     temphtab = htab.of (i);  // dm/kmd 4/15
-		    
-// dm/kmd 4/15	    if ( htab.of (i) == fcode ) {
-		    if ( temphtab == fcode ) {
+		    if ( htab.of (i) == fcode ) {
 			ent = codetab.of (i);
 			continue next_byte;
 		    }
-// dm/kmd 4/15		} while ( htab.of (i) > 0 );
-		} while ( temphtab > 0 );              // dm kmd 4/15
+		} while ( htab.of (i) > 0 );
 	    }
 
 	    output ( ent );
@@ -463,41 +527,6 @@
 	    output ( (int) Compress.CLEAR );
 	}
     }
-
-final class Hash_Table {                 // moved 4/15/98 dm/kmd
-/* Use protected instead of private
- * to allow access by parent class
- * of inner class. wnb 4/17/98
- */
-    protected int tab[];		// for dynamic table sizing */
-    protected int size;	
-
-    public Hash_Table() {
-	size = Compress.HSIZE;
-	tab = new int[size];
-    }
-
-    public int of(int i) {
-	return tab[i];
-    }
-
-    public void set(int i, int v) {
-	tab[i] = v;
-    }
-
-    public int hsize() {
-	return size;
-    }
-
-    public void clear() {
-	int i;
-
-	for (i = 0; i < size; i++) {
-	    tab[i] = -1;
-	}
-    }
-};
-
 };
 
 
@@ -678,65 +707,6 @@
 
 	return code;
     }
-
-/*****************************************************************/
-
-final class De_Stack {                         // moved 4/15/98 dm/kmd
-/* Use protected instead of private
- * to allow access by parent class
- * of inner class. wnb 4/17/98
- */
-    protected byte tab[];
-    protected int index;
-
-    public De_Stack() {
-	tab = new byte[Compress.STACK_SZ];
-	index = 0;
-    }
-
-    public void push(byte c) {
-	tab[index++] = c;
-    }
-
-    public byte pop() {
-	index--;
-	return tab[index];
-    }
-
-    public boolean is_empty() {
-	return (index == 0);
-    }
-};
-
-/*****************************************************************/
-
-final class Suffix_Table {                     // moved 4/15/98 dm/kmd
-/* Use protected instead of private
- * to allow access by parent class
- * of inner class. wnb 4/17/98
- */
-    protected byte tab[];
-
-    public Suffix_Table () {
-	tab = new byte[Compress.SUFFIX_TAB_SZ];
-    }
-
-    public byte of(int i) {
-	return tab[i];
-    }
-
-    public void set(int i, byte v) {
-	tab[i] = v;
-    }
-
-    public void init(int size) {
-	int code;
-	for ( code = 0; code < size; code++ ) {
-	    tab[code] = (byte)code;
-	}
-    }
-};
-
 };
 
 
diff -u compress1/Main.java compress/Main.java
--- compress1/Main.java	Fri Jun 26 21:42:33 1998
+++ compress/Main.java	Mon Nov 30 18:39:00 1998
@@ -6,15 +6,12 @@
  * This source code is provided as is, without any express or implied warranty.
  */
 
-package spec.benchmarks._201_compress;
-import spec.harness.*;
-
-public class Main implements SpecBenchmark {
+public class Main {
 
 
     static long runBenchmark( String[] args ) {
 
-     int speed = spec.harness.Context.getSpeed();
+     int speed = 100;
 
         if( args.length == 0 ) {
 
@@ -46,18 +43,11 @@
                               }	
                                  }
 
-    	return new Harness().inst_main( args );
+    	return new MyCompress().inst_main( args );
     }
 
 
     public static void main( String[] args ) {  	 
         runBenchmark( args );
     }
-
-    
-    public long harnessMain( String[] args ) {
-        return runBenchmark( args );
-    }
-
-  
 }
diff -Nu compress1/MyCompress.java compress/MyCompress.java
--- compress1/MyCompress.java	Thu Jan  1 01:00:00 1970
+++ compress/MyCompress.java	Fri Oct 25 22:01:30 2002
@@ -0,0 +1,118 @@
+/*
+ * @(#)Harness.java	1.14 06/26/98
+ *
+ * Copyright (c) 1998 Standard Performance Evaluation Corporation (SPEC)
+ *               All rights reserved.
+ * Copyright (c) 1997,1998 Sun Microsystems, Inc. All rights reserved.
+ *
+ * Modified by Kaivalya M. Dixit & Don McCauley (IBM) to read input files
+ * This source code is provided as is, without any express or implied warranty.
+ */
+
+import java.io.*;
+
+public final class MyCompress
+{
+
+	final static int COMPRESS = 0;
+	final static int UNCOMPRESS = 1;
+
+	private byte orig_text_buffer[];
+	private byte comp_text_buffer[];
+
+	private int fill_text_buffer(String infile) {
+		int act = 0;
+		int num_bytes = 0;
+
+		try {
+
+			java.io.FileInputStream sif = new java.io.FileInputStream(infile);
+			java.io.File myfile = new File(infile);
+			num_bytes = (int) myfile.length();
+
+			// Only allocate size of input file rather than MAX - kmd
+			// If compressed file is larger than input file this allocation 
+			// will fail and out of bound exception will occur 
+			// In real lie, compress will no do any compression as no
+			// space is saved.-- kaivalya
+
+			orig_text_buffer = new byte[num_bytes];
+			comp_text_buffer = new byte[num_bytes];  
+
+			int bytes_read;
+			while ( (bytes_read = sif.read(orig_text_buffer, act , (num_bytes - act))) > 0){
+				act = act +  bytes_read;
+				}
+
+			sif.close();    // release resources 
+
+			if ( act != num_bytes ) {
+				System.out.println("ERROR reading test input file");
+				}
+			}
+		catch (IOException e) {
+			System.out.println("ERROR opening/accessing input file: "+infile);
+			};
+
+		return act;
+		}
+
+
+	public MyCompress() {
+		/*
+		orig_text_buffer = new byte[BUFFERSIZE];
+		comp_text_buffer = new byte[BUFFERSIZE];
+		new_text_buffer = new byte[BUFFERSIZE];
+		*/
+		}
+
+	public boolean run_compress(String[] args) {
+		int count = 0;
+		int i, oper;
+		int comp_count, new_count;
+		int fn = Integer.parseInt(args [0] );     // get number of files
+		int loopct = Integer.parseInt(args [1] ); // get loop count
+
+		System.out.println( "Loop count = " + loopct );
+
+		for (int cntr=0; cntr < loopct; cntr++ )           // iterate over
+			for (int j=0; j < fn ; j++) {		           // number of files
+				count = fill_text_buffer( args [j+2] );    // give file names to read
+				oper=COMPRESS;
+				System.out.println( count);  // write input file size
+
+				// uncompress in the original text buffer.
+				comp_count=Compress.spec_select_action(orig_text_buffer, count,
+				oper, comp_text_buffer);
+				System.out.println( comp_count); // write compressed file size
+
+				oper=UNCOMPRESS;
+				new_count=Compress.spec_select_action(comp_text_buffer, comp_count,
+				oper, orig_text_buffer); 
+				// if uncompressed files size is not same as the original ERROR
+
+				if ( new_count != count ) {
+					System.out.println ("Error : Number of Bytes should have been  " + count + " instead of " + new_count);
+					}
+
+				// Release resources to prevent resource leak
+				orig_text_buffer = null;
+
+				comp_text_buffer = null;
+				}
+		return true;
+		}
+
+
+	public long inst_main( String[] argv ) {	 
+
+		long startTime = System.currentTimeMillis();
+
+		if (!run_compress(argv))
+		return 0;
+
+		return System.currentTimeMillis() - startTime;
+		}
+
+}
+
diff -Nu compress1/Harness.java compress/Harness.java
--- compress1/Harness.java	Fri Jun 26 21:36:51 1998
+++ compress/Harness.java	Thu Jan  1 01:00:00 1970
@@ -1,122 +0,0 @@
-/*
- * @(#)Harness.java	1.14 06/26/98
- *
- * Copyright (c) 1998 Standard Performance Evaluation Corporation (SPEC)
- *               All rights reserved.
- * Copyright (c) 1997,1998 Sun Microsystems, Inc. All rights reserved.
- *
- * Modified by Kaivalya M. Dixit & Don McCauley (IBM) to read input files
- * This source code is provided as is, without any express or implied warranty.
- */
-
-package spec.benchmarks._201_compress;
-import spec.harness.*;
-
-import java.io.*;
-
-public final class Harness
-{
-
-    final static int COMPRESS = 0;
-    final static int UNCOMPRESS = 1;
-
-    private byte orig_text_buffer[];
-    private byte comp_text_buffer[];
-
-    private int fill_text_buffer(String infile) {
-      int act = 0;
-      int num_bytes = 0;
-       
-      try {
-		
-        spec.io.FileInputStream sif = new spec.io.FileInputStream(infile);
-        num_bytes = (int)sif.getContentLength();
-        
-        // Only allocate size of input file rather than MAX - kmd
-        // If compressed file is larger than input file this allocation 
-	// will fail and out of bound exception will occur 
-	// In real lie, compress will no do any compression as no
-	// space is saved.-- kaivalya
-	
-	orig_text_buffer = new byte[num_bytes];
-	comp_text_buffer = new byte[num_bytes];  
-
-	int bytes_read;
-	 while ( (bytes_read = sif.read(orig_text_buffer, act , (num_bytes - act))) > 0){
-	   act = act +  bytes_read;
-	 }
-
-	 sif.close();    // release resources 
-        
-	 if ( act != num_bytes )
-            {
-            spec.harness.Context.out.println("ERROR reading test input file");
-            }
-      }
-      catch (IOException e)
-	  {
-	 spec.harness.Context.out.println("ERROR opening/accessing input file: "+infile);
-         };
-
-      return act;
-      }
-
-
-    public Harness() {
-	/*
-	orig_text_buffer = new byte[BUFFERSIZE];
-	comp_text_buffer = new byte[BUFFERSIZE];
-	new_text_buffer = new byte[BUFFERSIZE];
-	*/
-    }
-
-    public boolean run_compress(String[] args) {
-	int count = 0;
-	int i, oper;
-	int comp_count, new_count;
-	int fn = Integer.parseInt(args [0] );     // get number of files
-	int loopct = Integer.parseInt(args [1] ); // get loop count
-
-    spec.harness.Context.out.println( "Loop count = " + loopct );
-
-    for (int cntr=0; cntr < loopct; cntr++ )  // iterate over
-     for (int j=0; j < fn ; j++)            { // number of files
-     count = fill_text_buffer( args [j+2] );  // give file names to read
-     oper=COMPRESS;
-     spec.harness.Context.out.println( count);  // write input file size
-     
-     // uncompress in the original text buffer.
-     comp_count=Compress.spec_select_action(orig_text_buffer, count,
-     				   oper, comp_text_buffer);
-     spec.harness.Context.out.println( comp_count); // write compressed file size
-	
-     oper=UNCOMPRESS;
-     new_count=Compress.spec_select_action(comp_text_buffer, comp_count,
-     				  oper, orig_text_buffer); 
-     // if uncompressed files size is not same as the original ERROR
-
-     if ( new_count != count ) {
-          spec.harness.Context.out.println ("Error : Number of Bytes should have been  " + count + " instead of " + new_count);
-	    }
-
-         // Release resources tor prevent  resource leak
-         orig_text_buffer = null;
-	 comp_text_buffer = null;
-	
-    }
-	return true;
-    }
-		
-
-    public long inst_main( String[] argv ) { 
-
-        long startTime = System.currentTimeMillis();
-    
-        if (!run_compress(argv))
-            return 0;
-        
-        return System.currentTimeMillis() - startTime;
-    }
-
-}
-
