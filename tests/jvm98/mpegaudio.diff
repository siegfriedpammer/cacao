diff -Nu mpegaudio1/Context.java mpegaudio/Context.java
--- mpegaudio1/Context.java	Thu Jan  1 01:00:00 1970
+++ mpegaudio/Context.java	Tue Nov 26 11:35:40 2002
@@ -0,0 +1,444 @@
+/*
+ * @(#)Context.java	1.31 06/17/98
+ *
+ * Copyright (c) 1998 Standard Performance Evaluation Corporation (SPEC)
+ *               All rights reserved.
+ * Copyright (c) 1997,1998 Sun Microsystems, Inc. All rights reserved.
+ *
+ * This source code is provided as is, without any express or implied warranty.
+ */
+
+package spec.harness;
+
+/**
+ * This class is used to define the context for the execution of the
+ * benchmark. This container class has the parameters which can hold
+ * the benchmark run specific parameters like the run time, speed, 
+ * files opened, number of cached_files, SpecBasePath, console window
+ * for displaying the trace
+ */
+
+
+public final class Context{
+
+/**
+ * SpecBasePath is used to define the base directory of the specJava
+ * @see java.lang.String
+ */
+  private static String SpecBasePath = "";
+
+/**
+ * NetworkAccess flag is used to define whether the benchmark uses
+ * the network or not
+ */
+  static boolean NetworkAccess = false;
+
+/**
+ * BasePath 
+ * @see java.lang.String
+ */
+  static String BasePath = "";
+
+/**
+ * speed is used to define the benchmark run length. The benchmarks
+ * can be run at 1%, 10% and 100% of their full length of execution.
+ * Some times the % variation is reflected by just altering the loop
+ * count in the benchmark (ie repeatedly executing the same benchmark)
+ */ 
+  static int speed = 100;
+
+/**
+ * CachedInput is flag used to indicate, whether the classes have to 
+ * be cached or not. When the benchmark is run by the harness. The 
+ * classes are fetched over the net during the first run. The execution
+ * time in this case includes the network load time. Depending on the 
+ * user selection this flag will be toggled and used to cache the 
+ * classes loaded first time. The second run uses these cached 
+ * classes if flag is turned on.
+ */
+  static boolean CachedInput = true;
+  
+/**
+ * IOtime is gives the cumilative io time of the all the io calls in
+ * in the execution of the benchmark. The refference time is taken 
+ * before entering the io routine and the refference time is taken at
+ * the time of exiting from the routine. The difference between them 
+ * gives the time sepent in that routine. All such times are 
+ * accumilated to give the overall io time in the benchmark execution.
+ * see @java.lang.System#getSystemTime
+ */
+  static boolean batch = false;
+
+/**
+ * This flag is used to turn on/off the graphicsMode. Some of the tests 
+ * have the graphics in them. The graphics are conditionally enabled or 
+ * disabled depending on the final version of SpecJava
+ */
+  static boolean graphicsMode = false;
+
+/**
+ * The parameter is used to for storing the IOtime of the current benchmark
+ * under execution.
+ */
+  static long IOtime = 0;
+  
+/**
+ * num_files_open is an integer variable to hold the number of files 
+ * opened during the benchmark run. 
+ */
+  static int num_files_open = 0;
+  
+/**
+ * cached_data is an integer variable to hold the number of bytes of
+ * data that is cached. This can be more than zero for the first run
+ * but this has to be zero for the subsequent runs.
+ */
+  static int cached_data = 0;
+  
+/**
+ * num_cached_files is an integer variable to hold the number of files
+ * cached during the run of the benchmark. 
+ */
+  static int num_cached_files = 0;
+  
+/**
+ * userPropFile is the string used to hold the user profile file name
+ * The user profile file has the user specific data, which can also be 
+ * modified by using the setup key. The Setup parameters are initialized
+ * with the data from the user profile file
+ */
+  static String userPropFile;
+  
+/**
+ * verify flag is used to turn on/off the verification process of benchmark
+ * runs.
+ */
+  static boolean verify = true;
+  
+/**
+ * commandLineMode is a flag that holds the value which indicate whether the 
+ * benchmark is running in command line mode or as an applet.
+ */
+  static boolean commandLineMode = false;  
+  
+/**
+ * window is the ConsoleWindow object type where the trace of the 
+ * benchmark execution is displayed.
+ * @see spec.harness.ConsoleWindow
+ */
+  
+/**
+ * out is the PrintStream into which the trace messages will be written.
+ * This is assigned to the System.output stream by default
+ */
+  public static java.io.PrintStream out = System.out;
+  
+/**
+ * This function returns the integer value given the String form
+ * of it. In case of any number format exception, the function returns
+ * default value.
+ * @param s String value passed
+ * @param deft the default value to be returned.
+ */
+  public static int getValue(String s, int deft) {
+
+      try {
+	  return Integer.parseInt(s, 10);
+      } catch(NumberFormatException x) {}
+            
+      return deft;
+  }
+    
+/**
+ * This function creates the new Console window and the print stream
+ * @see spec.harness.ConsoleWindow
+ */
+  public static void setupConsoleWindow(){
+  }
+  
+/**
+ * This function set the  SpecBasePath to the string value passed with
+ * some data stripped.
+ * @param basePath The URL of the file
+ */
+  public static void setSpecBasePath(String basepath){
+    if (basepath.indexOf("file:" , 0) == 0){
+	SpecBasePath = basepath.substring(5);
+    }
+    else{
+        SpecBasePath = basepath;
+    }
+    
+    if (SpecBasePath.indexOf("http:" , 0) == 0){
+	NetworkAccess = true;
+    } else {
+	while (SpecBasePath.charAt(0) == '/' && SpecBasePath.charAt(1) == '/') {
+	    SpecBasePath = SpecBasePath.substring(1); 
+	}   
+    }   
+  }
+
+/**
+  returns the specbase path
+ */
+  public static String getSpecBasePath(){
+	return SpecBasePath;     
+  }
+
+/**
+ * Increments the the cached_data parameter by the integer passed.
+ * @param num increment value
+ */
+  public static void addCachedDataSize(int num){
+    cached_data += num;
+  }
+  
+/**
+ * gets the cached data size. 
+ * @return The cached_data value
+ */
+  public static int getCachedDataSize(){
+    return cached_data;
+  }
+  
+/**
+ * Increments the the num_cached_files parameter by 1.
+ */
+  public static void IncrementNumCachedFiles(){
+    num_cached_files++;
+  }
+  
+/**
+ * gets the numbef of cached files. 
+ * @return The num_cached_files value
+ */
+  public static int getNumCachedFiles(){
+    return num_cached_files;
+  }
+  
+/** 
+ * Increments the number of Files open parameter. The number of files 
+ * open parameter is used for debugging purposes to findout whether the 
+ * finalizers are called or not
+ */
+  public static void IncrementNumOpenFiles(){
+    num_files_open++;
+  }
+  
+/** 
+ Decrements the number of Files open parameter 
+ */  
+  public static void DecrementNumOpenFiles(){
+    num_files_open--;
+  }
+  
+/** 
+ returns the number of files open
+ */  
+  public static int getNumOpenFiles(){
+    return num_files_open;
+  }
+
+/**
+ *  sets the benchmark relative path. For example if  SpecBasepath is
+ * /var/htdocs/v11/spec, The relative benchmark path path for
+ * _201_compress is benchmarks/_201_compress. This function adds these
+ * two strings and forms the BasePath
+ * BasePath = /var/htdocs/v11/spec + benchmarks/_201_compress
+ * @param rpath Relative path of the benchmark
+ */
+  public static void setBenchmarkRelPath(String rpath){
+    BasePath = SpecBasePath + rpath;
+  }
+  
+  
+/**
+ * This function changes the basepath to point to the input directory
+ * of the benchmark. this function just concatinates the "/input" 
+ * to the existing basepath if it is not added already.
+ */
+  public static void cdInput(){
+    if( !BasePath.endsWith( "input/" )) {
+	BasePath = BasePath + "input/" ;
+    }
+  }
+  
+/** 
+ * Sets the network access flag 
+ * @param flag Flag indicating the network access
+ */  
+  public static void setNetworkAccess(boolean flag){
+
+    NetworkAccess = flag;
+  }
+
+/**
+ Returns the spec base path. This function is handly in loading the files
+ from the relative directories.
+ */
+  public static String getBasePath(){
+
+    return BasePath;
+  }
+
+/**
+ Indicates whether SpecJVMClient is running as an applet or application
+ */
+  public static boolean isNetworkAccess(){
+
+    return NetworkAccess;
+
+  }
+
+/** 
+ * Sets the speed of execution to the value passed. Depending on the 
+ * user's selection, the speed of execution is set as 1% 10% or 100%
+ * @param n Speed selected by the user
+ */  
+  public static void setSpeed( int n ) {
+    speed = n;
+  }
+  
+/**
+ Returns the speed of the benchmark.
+ */  
+  public static int getSpeed() {
+    return speed;
+  }
+
+/**
+ Sets the CachedInput flag. The data is read from the Cache during the second
+ run if this flag is set.
+ */
+  public static void setCachedInputFlag( boolean cif ){
+    CachedInput = cif;
+  }
+
+/**
+ Sets the batch flag
+ @param b boolean value for the batch flag
+ */
+  public static void setBatch( boolean b ){
+    batch = b;
+  }
+
+/**
+ Returns whether SpecJVMClient is running in batch mode
+ */
+  public static boolean isBatch(){
+    return batch;
+  }
+
+/**
+ Sets the graphics mode. Normally SepcJVM client runs with graphics disabled.
+ This flag is for future extensions and debugging
+ */    
+  public static void setGraphicsMode (boolean mode){
+    graphicsMode = mode;
+  }
+
+/**
+ Returns the graphic mode flag value
+ */    
+  public static boolean getGraphicsMode(){
+    return graphicsMode;
+  }
+
+/**
+ Sets the user properties file. These properties are stored in the mail sent at
+ the end of the test
+ @param s Properties file name 
+ */
+  public static void setUserPropFile( String s){
+    userPropFile = s;
+  }
+
+/**
+ Returns the properties file name
+ */
+  public static String getUserPropFile(){
+    return userPropFile;
+  }
+
+/**
+ Returns the cached input flag
+ */
+  public static boolean isCachedInput(){
+    return CachedInput;
+  } 
+  
+/**
+ Clears the IOtiming. This is normally done before starting a benchmark
+ */  
+  public static void clearIOtime(){
+    IOtime = 0;
+  }
+
+/**
+ Increments the IOTime by the value provided
+ @param time Incremental value
+ */
+  public static void addIOtime(long time){
+    IOtime = IOtime + time;
+  }
+
+/**
+ Returns the IO time 
+ */    
+  public static long getIOtime(){
+    return IOtime;
+  }
+ 
+    /**
+     * Set commandLineMode flag
+     */
+    public static void setCommandLineMode(boolean value) {
+	commandLineMode = value;
+    }
+
+
+    /**
+     * Get commandLineMode flag
+     */
+    public static boolean getCommandLineMode() {
+	return commandLineMode;
+    }
+
+
+    /**
+     * Set verify flag
+     */
+    public static void setVerify(boolean value) {
+	verify = value;
+    }
+
+
+    /**
+     * Get verify flag
+     */
+    public static boolean getVerify() {
+	return verify;
+    }
+    
+          
+    /**
+     * Start output window
+     */
+    public static void startOutputWindow() {   
+    }  
+        
+	    
+    /**
+     * Stop output window
+     */
+    public static void stopOutputWindow() {
+    }   
+	    
+    /**
+     * Output to console window
+     */
+    public static void appendWindow(String s) {
+	    System.out.print(s);
+    }       
+}
+
diff -Nu mpegaudio1/File.java mpegaudio/File.java
--- mpegaudio1/File.java	Thu Jan  1 01:00:00 1970
+++ mpegaudio/File.java	Tue Nov 26 11:02:12 2002
@@ -0,0 +1,356 @@
+/*
+ * @(#)File.java	1.5 06/17/98
+ *
+ * Copyright (c) 1998 Standard Performance Evaluation Corporation (SPEC)
+ *               All rights reserved.
+ * Copyright (c) 1997,1998 Sun Microsystems, Inc. All rights reserved.
+ *
+ * This source code is provided as is, without any express or implied warranty.
+ */
+
+package spec.io;
+
+/** 
+ This class extends the java.io.File and provides some extra functionality. 
+ File object maintains a static table of files called the Table of existing
+ files. The files listed in the TableOfExisting files are loaded from the
+ local disk. All the other files are loaded over the network.
+*/
+public class File extends java.io.File{
+
+/** 
+ Variable representing the file name
+ */
+  
+  String filename;
+
+/** 
+ Table to hold the ListOfExisting files
+ */
+  private static TableOfExistingFiles tef = new TableOfExistingFiles();
+  
+/**
+ Constructor.
+ @param Path of the file (includes the file name also)
+ */
+  public File(String path){
+
+    super(path);
+
+    //System.out.println("Inside constructor File(" + path + ")");
+
+    filename = path;
+
+  }
+
+/**
+ Overloaded constructor which takes the path and the files name to load the
+ file
+ @param path Directory of the file
+ @param name file name
+ */
+  public File(String path , String name){
+
+    super(path , name);
+
+    //System.out.println("Inside constructor File(" + path + " , " + name + ")");
+
+    filename = path + name;
+
+  }
+
+/**
+ Overloaded constructor which takes the directory in the File object format
+ and a name of the file.
+ @param dir Directory of the file in the File object format
+ @param name file name
+ */
+  public File(File dir , String name){
+
+    super(dir , name);
+
+    //System.out.println("Inside constructor File(dir, name) , dir.getName = " + dir.getName());
+
+    filename = dir.getPath() + name;
+
+  }
+
+/**
+ returns the name of the file
+ @return name of file
+ */
+  public String getName(){
+
+    String returnvalue = super.getName();
+
+    //System.out.println("Inside File.getName() , \nfilename = " + filename + "\nreturnvalue = " +returnvalue);
+
+    
+    return returnvalue;
+
+  }
+
+/**
+ returns the path of the file
+ */
+  public String getPath(){
+
+    String returnvalue = super.getPath();
+    
+    //System.out.println("Inside File.getPath() ,  filename = " + filename + " returnvalue = " +returnvalue);
+
+    return returnvalue;
+
+  }
+
+/**
+ returns tha absolutePath of the file Dir + name
+ */
+  public String getAbsolutePath(){
+
+    String returnvalue = super.getAbsolutePath();
+   
+    //System.out.println("Inside File.getAbsolutePath() ,  filename = " + filename + " returnvalue = " + returnvalue);
+
+    return returnvalue;
+
+  }
+
+/**
+ returns the Parent directory name
+ */
+
+  public String getParent(){
+
+    String returnvalue = super.getParent();
+
+    //String returnvalue = null;
+
+    //System.out.println("Inside File.getParent() ,  filename = " + filename + " returnvalue = " + returnvalue);
+
+    return returnvalue;
+
+  }
+
+/**
+ Checks whether the given file name exists or not
+ */
+  public boolean exists(){
+
+    //boolean returnvalue = super.exists();
+    
+    boolean returnvalue = tef.exists( filename.replace( '\\', '/' ) );
+
+    //System.out.println("Inside File.exists() ,  filename = " + filename + " returnvalue = " + returnvalue);
+
+    return returnvalue;
+
+  }
+
+/**
+ Checks whether the given file is writablle or not
+ */  
+  public boolean canWrite(){
+    
+    boolean returnvalue = super.canWrite();
+
+    //System.out.println("Inside File.canWrite() ,  filename = " + filename + " returnvalue = " + returnvalue);
+
+    return returnvalue;
+
+  }
+
+/**
+ Checks whether the given file is readable
+ */
+  public boolean canRead(){
+    
+    boolean returnvalue = super.canRead();
+
+    //System.out.println("Inside File.canRead() ,  filename = " + filename + " returnvalue = " + returnvalue);
+
+    return returnvalue;
+
+  }  
+
+/**
+ Checks whether the given file name is a file or directory
+ The functionality is modified to return whether the file name is classes.zip
+ or not
+ */
+  public boolean isFile(){
+   
+    //boolean returnvalue = super.isFile();
+
+    boolean returnvalue = filename.endsWith("classes.zip");
+
+    //System.out.println("Inside File.isFile() ,  filename = " + filename + " returnvalue = " + returnvalue);
+
+    return returnvalue;
+
+  }  
+
+/**
+ Checks whether the given file name is directory or not
+ */
+  public boolean isDirectory(){
+    
+    boolean returnvalue = super.isDirectory();
+
+    //System.out.println("Inside File.isDirectory() ,  filename = " + filename + " returnvalue = " + returnvalue);
+
+    return returnvalue;
+
+  }
+
+/**
+ Returns the date of last modification
+ */
+  public long lastModified(){
+
+    long returnvalue = super.lastModified();
+    
+    //System.out.println("Inside File.lastModified() ,  filename = " + filename + " returnvalue = " + returnvalue);
+
+    return returnvalue;
+
+  }
+
+/**
+ Returns the length of the file
+ */
+  public long length(){
+    
+    long returnvalue = super.length();
+
+    //System.out.println("Inside File.length() ,  filename = " + filename + " returnvalue = " + returnvalue);
+
+    return returnvalue;
+
+  }
+
+/**
+ Creates a new directory
+ */
+  public boolean mkdir(){
+
+    boolean returnvalue = super.mkdir();
+
+    //System.out.println("Inside File.mkdir() ,  filename = " + filename + " returnvalue = " + returnvalue);
+
+    return returnvalue;
+
+  }
+
+/**
+ Renames the file
+ */
+  public boolean renameTo(File dest){
+
+    boolean returnvalue = super.renameTo(dest);
+
+    //System.out.println("Inside File.renameTo() ,  filename = " + filename +  " returnvalue = " + returnvalue);
+
+    return returnvalue;
+
+  }
+
+/**
+  Creates a directory whose pathname is specified by this File object, 
+  including any necessary parent directories. 
+ */  
+  public boolean mkdirs() {
+
+    boolean returnvalue = super.mkdirs();
+
+    //System.out.println("Inside File.mkdirs() ,  filename = " + filename +  " returnvalue = " + returnvalue);
+
+    return returnvalue;
+
+  }
+
+/**
+ Returns a list of the files in the directory specified by this File object
+*/
+  public String[] list(){
+ 
+    String[] returnvalue = super.list();
+    
+    //System.out.println("Inside File.list() ,  filename = " + filename +  " returnvalue = " + returnvalue);
+
+    return returnvalue;
+
+  }
+
+/**
+ Returns a list of the files in the directory specified by this File that 
+ satisfy the specified filter. 
+*/ 
+  public String[] list(java.io.FilenameFilter filter){
+ 
+    String[] returnvalue = super.list(filter);
+
+    //System.out.println("Inside File.list(filter) ,  filename = " + filename +  " returnvalue = " + returnvalue);
+
+    return returnvalue;
+
+  }
+
+/**
+ Deletes the file specified by this object. 
+ */ 
+  public boolean delete(){
+
+    boolean returnvalue = super.delete();
+
+    //System.out.println("Inside File.delete() ,  filename = " + filename +  " returnvalue = " + returnvalue);
+    
+    return returnvalue;
+
+  }
+
+/**
+ Computes a hashcode for the file. 
+ */
+  public int hashCode(){
+
+    int returnvalue = super.hashCode();
+
+    //System.out.println("Inside File.hashcode() ,  filename = " + filename +    " returnvalue = " + returnvalue);
+
+    return returnvalue;
+
+  }
+
+/**
+ Compares this object against the specified object.  
+ */
+  public boolean equals(Object obj){
+
+    boolean returnvalue = super.equals(obj);
+
+    //System.out.println("Inside File.equals() ,  filename = " + filename +  " returnvalue = " + returnvalue);
+
+    return returnvalue;
+  }
+
+/**
+ Returns a string representation of this object. 
+*/  
+  public String toString(){
+
+    String returnvalue = super.toString();
+
+    //System.out.println("Inside File.toString() ,  filename = " + filename +  " returnvalue = " + returnvalue);
+
+    return returnvalue;
+
+  }
+
+}
+    
+    
+    
+    
+  
+    
diff -Nu mpegaudio1/FileCacheData.java mpegaudio/FileCacheData.java
--- mpegaudio1/FileCacheData.java	Thu Jan  1 01:00:00 1970
+++ mpegaudio/FileCacheData.java	Tue Nov 26 11:01:41 2002
@@ -0,0 +1,105 @@
+/*
+ * @(#)FileCacheData.java	1.3 06/17/98
+ *
+ * Copyright (c) 1998 Standard Performance Evaluation Corporation (SPEC)
+ *               All rights reserved.
+ * Copyright (c) 1997,1998 Sun Microsystems, Inc. All rights reserved.
+ *
+ * This source code is provided as is, without any express or implied warranty.
+ */
+
+package spec.io;
+
+import java.util.*;
+
+/**
+ SpecJVMClient maintains the internal cache. The data is read over the network
+ for the first run and it is cached. The cached data is used for subsequent runs
+ The FileInputStream object contains a FileCacheData object which caches data
+ @see spec.io.FileInputStream
+  */
+public class FileCacheData{
+
+/**
+ Data buffer to cache data
+ */
+  private byte[] data = null;
+
+/**
+ Total number of bytes present in the data buffer at anytime
+ */    
+  private int total_num_bytes = 0;
+  
+/**
+ Constructor 
+ @param len Length of the file. The byte array of 'len' size is created
+ */ 
+  public FileCacheData(int len){
+    
+    data = new byte[len];
+
+  }
+ 
+/**
+ Creates the byte array to hold the file data. The size of the file is passed
+ as argument.
+ @param len Length of the file
+ */
+  public void createData(int len){
+    
+    data = new byte[len];
+
+  }
+
+/**
+ Copies the given specified of bytes from the given buffer from given offset
+ to the data buffer of the FileCacheData object
+ @param b[] 'from' byte array
+ @param off Offset within the byte array
+ @param num_bytes Number of bytes to be copied
+ */
+  public void copyData(byte b[] , int off , int num_bytes){
+    
+    System.arraycopy(b,off,data,total_num_bytes, num_bytes);
+    total_num_bytes += num_bytes;
+
+  }
+  
+/**
+ Copies the byte to the data buffer. Increments the number of bytes field
+ @param b byte to be copied
+ */
+  public void copyData(byte b){
+
+    data[total_num_bytes] = b;
+    total_num_bytes += 1;
+
+  }
+
+/**
+ Skips a portion of buffer
+ */
+  public void skipPos(long n){
+    total_num_bytes += n;
+  }
+
+ /**
+  Converts the data buffer array to InputStream
+  */
+  public java.io.InputStream getInputStream(){
+
+    return new java.io.ByteArrayInputStream(data , 0 , total_num_bytes);
+
+  }
+
+/**
+ Returns the length of the buffer. 
+ */
+  public int getLength(){
+    return total_num_bytes;
+  }
+
+}
+
+
+
diff -Nu mpegaudio1/FileInputStream.java mpegaudio/FileInputStream.java
--- mpegaudio1/FileInputStream.java	Thu Jan  1 01:00:00 1970
+++ mpegaudio/FileInputStream.java	Tue Nov 26 11:28:57 2002
@@ -0,0 +1,893 @@
+/*
+ * @(#)FileInputStream.java	1.33 06/17/98
+ *
+ * Copyright (c) 1998 Standard Performance Evaluation Corporation (SPEC)
+ *               All rights reserved.
+ * Copyright (c) 1997,1998 Sun Microsystems, Inc. All rights reserved.
+ *
+ * This source code is provided as is, without any express or implied warranty.
+ */
+
+package spec.io;
+
+import java.util.*;
+import java.net.*;
+//import spec.harness.*;
+
+
+/**
+ This class extends the java.io.InputStream and provides some extra functionality
+ for caching the data. It also keeps a count of the number of filestreams
+ opened by the SpecJVMClient, number of files read, number of bytes read,
+ io times spent
+ @see java.io.InputStream
+ @see spec.io.FileCacheData
+ */
+public class FileInputStream extends java.io.InputStream{
+  
+
+
+  //************************* Static variables****************************//
+  // Constants
+  private static final int LENGTH_ERROR = -1;
+
+  // Cache variables
+
+/**
+ Maintains a list of cached files
+ */    
+  private static Hashtable filecache = new Hashtable();
+
+/**
+ Maintains a list of opened InputStreams
+ */
+  private static Vector openedInputStreams = new Vector();
+
+/**
+ Enables or disables the Debug mode of operation
+ */
+  public  static boolean debug = false;
+  public  static boolean testing = false;
+
+/**
+ Keeps a count of closed filestreams
+ */  
+  public  static int numofCloses = 0;
+
+  // How and whether to retry http operations
+/**
+ Number of retries before declaring the error in opening the file
+ */  
+  private static int nRetry = 5;		// times to try
+
+/**
+ Sleep time between two successive retries
+ */  
+  private static int retryDelay = 5000;		// milliseconds
+
+/**
+ Total retries made throughout the benchmark suit
+ */    
+  private static int totalRetries = 0;		// count over all benchmarks
+
+/**
+ A flag to control which API to be used
+ */
+  private static boolean use11net = true;	// use 1.1 API instead of
+
+  // IO Stats variables
+
+/**
+ Number of open files
+ */  
+  private static int num_open_files = 0;
+
+/**
+ Number of files used
+ */  
+  private static int num_files_used = 0;
+
+/**
+ Number of cached files
+ */  
+  private static int num_cached_files = 0;
+
+/**
+ Size of the cache at a given time
+ */  
+  private static int size_cached_data = 0;
+
+/**
+ Total number of bytes read from the cache for executing this benchmark
+ */  
+  private static int total_num_of_byte_reads_from_cache = 0;
+  
+/**
+ Total number of bytes read from file
+ */  
+  private static int total_num_of_byte_reads_from_file = 0;
+  
+/**
+ Total number of bytes read from the URL  
+ */
+  private static int total_num_of_byte_reads_from_url = 0;
+
+/**
+ Number of cache hits
+ */    
+  private static int num_cache_hits = 0;
+  
+/**
+ Number of cache misses or number of files hits
+ */
+  private static int num_cache_misses = 0;
+
+/**
+ IOtime for executing this benchmark
+ */    
+  private static long IOtime =0;
+  
+/**
+ Caching time for executing this benchmark
+ */
+  private static long Cachingtime = 0;
+  //********************** End Static variables****************************//
+
+ 
+
+  //************************* Static methods******************************//
+
+  // Cache methods
+
+/**
+ Clears the cache data and updates the Caching parameters
+ */
+  public static void clearCache(){
+    filecache = new Hashtable();
+    num_cached_files = 0;
+    size_cached_data = 0;
+    num_cache_hits = 0;
+    num_cache_misses = 0;  
+  }
+
+/**
+ Closes all the opened streams
+ */
+  public static void closeAll() throws java.io.IOException{
+
+    Enumeration all_opened_in_streams = openedInputStreams.elements();
+    if(debug) {
+        System.out.println("Close all called");
+    }
+
+    while(all_opened_in_streams.hasMoreElements()){
+      
+      try{
+	java.io.InputStream in = (java.io.InputStream)all_opened_in_streams.nextElement();
+	in.close();
+	num_open_files--;
+      }catch(NoSuchElementException e){
+      }
+    }
+
+  }
+  
+
+  // IO Stats methods
+
+  /*
+   * could be useful in debugging
+  public static String getListCachedFiles(){
+      StringBuffer buf = new StringBuffer();
+      for (Enumeration e = filecache.keys(); e.hasMoreElements(); ){
+	  buf.append ((String)(e.nextElement()));
+	  buf.append (",");
+      }
+      return buf.toString();
+  }
+   */
+/**
+ Returns the number of open files
+ */
+  public static int getNumOpenFiles(){
+    return num_open_files;
+  }
+
+/** 
+ Returns the number of used files
+ */    
+  public static int getNumUsedFiles(){
+    return num_files_used;
+  }
+  
+/** 
+ Returns the number of Cached files
+*/  
+  public static int getNumCachedFiles(){
+    return num_cached_files;
+  }
+  
+/**
+ Returns the size of the cached data
+*/  
+  public static int getCachedDataSize(){
+    return size_cached_data;
+  }
+
+ /**
+  Returns the number of bytes read from the cache
+  */
+  public static int getNumCacheByteReads(){
+    return total_num_of_byte_reads_from_cache;
+  }
+
+ /**
+  Returns the number of bytes read from the file
+  */
+  public static int getNumFileByteReads(){
+    return total_num_of_byte_reads_from_file;
+  }
+
+/**
+ Returns the number of bytes read form the URL
+ */    
+  public static int getNumUrlByteReads(){
+    return total_num_of_byte_reads_from_url;
+  }
+
+/**
+ Returns the number of cache hits in executing the current benchmark 
+ */    
+  public static int getNumCacheHits(){
+    return num_cache_hits;
+  }
+
+/**  
+ Returns the number of cache misses in executing the current benchmark 
+ */
+  public static int getNumCacheMisses(){
+    return  num_cache_misses;
+  }
+
+/**
+ Returns the IO time spent in executing the current benchmark 
+ */   
+  public static long getIOtime(){
+    return IOtime;
+  }
+
+/**
+ Returns the Caching time
+ */    
+  public static long getCachingtime(){
+    return Cachingtime;
+  }
+
+/**
+ Return the total retries
+ */
+  public static int getTotalRetries(){
+    return totalRetries;
+  }
+
+/**
+ Clears the IO statistics variables.
+ */    
+  public static void clearIOStats(){
+    num_files_used = 0;
+    total_num_of_byte_reads_from_cache = 0;
+    total_num_of_byte_reads_from_file = 0;
+    total_num_of_byte_reads_from_url = 0;
+    IOtime = 0;
+    Cachingtime = 0;
+  }
+
+/**
+ Checks whether the given URL is valid or not.
+ */
+  public static boolean IsURLOk(URL url){
+
+    /* should have no leading/trailing LWS
+     * expedite the typical case by assuming it has
+     * form "HTTP/1.x <WS> 2XX <mumble>"
+     */
+    int ind;
+    try {  
+      
+      URLConnection urlc = url.openConnection();
+    
+      String resp = urlc.getHeaderField(0);
+
+      if( resp == null ) {
+//	  System.out.println( "resp == NULL in IsURLOk" );
+	  return true;	   
+      }
+         
+      ind = resp.indexOf(' ');
+      while(resp.charAt(ind) == ' ')
+	ind++;
+      int responseCode = Integer.parseInt(resp.substring(ind, ind + 3));
+      
+      if (debug){
+	System.out.println("responseCode = " + responseCode);
+      }
+
+      return !( ((responseCode >= 400) && (responseCode <= 415)) || 
+		((responseCode >= 500) && (responseCode <= 505))
+		);
+            
+    } catch (java.io.IOException e) { 
+      System.out.println("Exception in IsURLOk " + e );	    
+      return false;
+    }
+
+  }
+
+
+/**
+ Constructs the URL for the server file given the file name
+ */
+  private static String makeGoodUrl(String str){
+
+    String retstr;
+
+    retstr = str.replace( '\\', '/' );
+    
+    int ind = 0;
+     
+    if (retstr.startsWith("http")){
+      ind = 6;
+    }
+
+    if (retstr.indexOf("//" , ind) != -1){
+      char c[] = retstr.toCharArray();
+      int len = retstr.length();
+      for(int i = ind; i < len; i++){
+	
+	if (c[i] == '/'){
+	  int j = i+1;
+
+	  while( (j < len) && (c[j] == '/') ){
+	    j = j+1;
+	  }
+	  if (j > (i+1)){
+	    for(int k = i+1 , l = j; l < len; l++ , k++){
+	      c[k] = c[l];
+	    }
+	    len = len - (j-i-1);
+	  }
+	}
+	retstr = new String(c , 0 , len);
+      }
+    }
+    return retstr; 
+  }
+
+  //********************** End Static methods****************************//
+
+  
+
+/**
+ The file URL
+ */  
+  private String my_file_url;
+
+/**
+  
+ */  
+  private java.io.InputStream orig_in;
+ 
+/**
+ Length of the FileInputStream
+ */   
+  private int len = 0;
+
+/**
+ Flag indicating whether the file stream is closed or not
+ */    
+  private boolean closed = false;
+
+/**
+ Flag indicating whether to cache the data during the first loading or not
+ */    
+  private boolean doCache;
+
+/**
+ Flag indicating whether the data is from the Cache
+ */    
+  private boolean fromCache = false;
+
+/**
+ Flag indicating whether the data is from URL
+ */  
+  private boolean fromUrl = false;
+  
+ /**
+  Updates the file read statistics
+  @param len Length of the FileStream
+  */
+  private void collectReadStats(int len){
+    
+    if (len <= 0){
+      return;
+    }
+    
+    if (fromCache){
+      total_num_of_byte_reads_from_cache += len;
+    }
+    else{
+      if (fromUrl){
+	total_num_of_byte_reads_from_url += len;
+      }
+      else{
+	total_num_of_byte_reads_from_file += len;
+      }
+    }
+
+  }
+    
+    
+    /**
+     * Main class constructor.
+     * 
+     * Try and find the strange URL open bug by catching any exceptions and calling the
+     * System finalizer to try and close the sockets.
+     */     
+    public FileInputStream(String input_filename) throws java.io.FileNotFoundException,
+				    java.net.MalformedURLException , java.io.IOException {
+	super();
+    
+	try {
+            construct(input_filename);
+	} catch(Exception a) {
+	    System.out.println ( "----------------------------------");
+	    System.out.println ( "spec.io.FileInputStream: Caught exception in constructor: "+a);
+	    System.out.println ( "trying to open: " + input_filename); //wnb
+	    System.out.println ( "spec.io.FileInputStream: Attempting recovery with System.runFinalization()");	    
+	    System.gc();
+	    System.runFinalization();
+	    try {
+		construct(input_filename);
+	    } catch(Exception b){
+   		System.out.println ( "----------------------------------");
+		System.out.println ( "spec.io.FileInputStream: Caught exception in constructor at second level: "+a);
+		if ( !(b instanceof java.io.FileNotFoundException) ) {
+		    System.out.println ( "spec.io.FileInputStream: Exiting benchmark");		    
+		    printStackTrace(b);
+		    throw new StopBenchmarkException( "spec.io.FileInputStream failure" );
+		} else {
+		    throw (java.io.FileNotFoundException)b;
+		}
+	    }
+	}
+    }
+
+/**
+ Constructs thd FileInputStream object from the given file name
+ */	    
+  private void construct(String input_filename) throws Exception{           
+      
+	long startTime = System.currentTimeMillis();
+
+	my_file_url = makeGoodUrl(input_filename);
+	
+	num_open_files++;
+	num_files_used++;
+
+	if (filecache.containsKey(my_file_url)){
+
+	  long cacheStartTime = System.currentTimeMillis();
+	
+	  doCache = false;    // no need to cache data -- data is already in cache
+	  fromCache = true;   // read data from cache
+	
+	  num_cache_hits++;   // we have a hit
+
+	  if (debug){
+	    System.out.println("\n++++++++making InputStream from cached " + my_file_url);
+	  }
+
+
+	  // Get the cached data from the filecache
+	  FileCacheData fcd = (FileCacheData)filecache.get(my_file_url);  
+
+	  // Get the length of the data
+	  len = fcd.getLength();
+
+	  // Get an inputStream to read data form the cache
+	  orig_in = fcd.getInputStream();
+
+	  long cacheEndTime = System.currentTimeMillis();
+	  Cachingtime += (cacheEndTime - cacheStartTime);
+	}
+	else{
+	
+	  num_cache_misses++;  // we have a miss
+	
+	  if (debug){
+	    System.out.println("\n++++++++Opening InputStream for " + my_file_url);
+	  }
+
+	
+	  openStream();  // open an inputStream through network or file I/O
+
+		
+	  if (false){
+
+	    long cacheStartTime = System.currentTimeMillis();
+	 
+	    doCache = true;  // we have to cache data
+
+	    // create a new FileCacheData object of size len and put it in the filecache 
+	    // with my_file_url as the key
+	
+	    FileCacheData fcd = new FileCacheData(len);  
+	    filecache.put(my_file_url , fcd);
+	  
+	    size_cached_data += len;
+	    num_cached_files++;
+	 
+	    long cacheEndTime = System.currentTimeMillis();
+	    Cachingtime += (cacheEndTime - cacheStartTime);
+	  }
+	  else{
+	    doCache = false;
+	  }
+
+	  // Keep track of all the InputStreams opened so far.
+	  openedInputStreams.addElement(orig_in);
+	
+	
+	}
+      
+	long endTime = System.currentTimeMillis();
+	long totalTime = endTime - startTime;
+
+
+	IOtime += totalTime;
+  } 
+  
+  
+  /**
+   * Prints the stack backtrace to Context.out. If this is an instance of
+   * spec.io.PrintStream (it normally will be) then the default validity
+   * check value is changed to '1'. This is the code that means all data
+   * should be compaired and will ensure that the benchmark fails the 
+   * validity check process.
+   */
+  void printStackTrace(Exception x) {
+      java.io.PrintStream str = System.out;      
+      x.printStackTrace(System.out);
+  }
+  
+/**
+ Opens the FileInputStream
+ */  
+  private void openStream() throws java.io.FileNotFoundException,
+      java.net.MalformedURLException , java.io.IOException{
+
+    if (false){
+      fromUrl = true;
+      URL url = new URL(my_file_url);
+      URLConnection urlc = url.openConnection();
+      len = urlc.getHeaderFieldInt("content-length", LENGTH_ERROR);
+      for (int retry=0; retry < nRetry && len == LENGTH_ERROR; retry++){
+        if (urlc instanceof HttpURLConnection)
+          ((HttpURLConnection) urlc).disconnect();
+        urlc = null;
+        System.gc();
+        System.runFinalization();
+	if (debug)
+            System.out.println ("GET failed on " + my_file_url);
+        try{
+          Thread.sleep (retryDelay);
+        }catch (InterruptedException e){}
+        urlc = url.openConnection();
+        urlc.connect();
+        len = urlc.getHeaderFieldInt("content-length", LENGTH_ERROR);
+	totalRetries++;
+      }
+      if (use11net && (urlc instanceof HttpURLConnection)){
+	HttpURLConnection urlh = (HttpURLConnection) urlc;
+	if (urlh.getResponseCode() != HttpURLConnection.HTTP_OK)
+	  throw new java.io.FileNotFoundException( my_file_url +
+	    ": " + urlh.getResponseMessage());
+      }else{
+        if (!IsURLOk(url))
+	  throw new java.io.FileNotFoundException( my_file_url );
+      }
+
+      if (len == LENGTH_ERROR){
+	throw new java.io.IOException("Cannot establish URL content-length");
+/*      
+	System.out.println("Error getting size of file -- turning off caching");
+	spec.harness.Context.setCachedInputFlag(false);
+*/	
+      }
+
+      if (debug){
+	if (len == LENGTH_ERROR){
+	  if (urlc == null){
+	    System.out.println("urlc is null");
+	  }
+	  else{
+	    System.out.println("urlc = " + urlc);
+	  }
+	}
+	System.out.println("++++++++spec.io.FileInputStream url len = " + len);
+      }
+
+      try{
+	orig_in = urlc.getInputStream();
+      }catch(java.io.IOException ioe){
+	System.out.println("Error trying to get an inputStream from url connection " + urlc);
+	throw ioe;
+      }
+
+    }else{    // NOT (Context.isNetworkAccess())
+    
+      File file = new File(my_file_url);
+      len = (int)file.length();
+
+      if (debug){
+	System.out.println("++++++++spec.io.FileInputStream file len = " + len);
+      }
+      orig_in = new java.io.FileInputStream(my_file_url);
+      
+    }
+  }
+	
+/**
+ Constructor
+ @param file File object
+ */	
+  public FileInputStream(spec.io.File file) throws java.io.FileNotFoundException,
+    java.net.MalformedURLException , java.io.IOException{
+        this(file.getPath());
+  }
+
+/**
+ Returns the stream length
+ */    
+  public int getContentLength(){
+  
+    return len;
+    
+  }
+
+/**
+  Returns the number of bytes that can be read from this input stream without 
+  blocking. 
+ */		
+  public synchronized int available() throws java.io.IOException{
+    
+    try{
+     
+      return orig_in.available();
+    
+    }catch(java.io.IOException ioe){
+      printStackTrace(ioe);
+      throw new StopBenchmarkException(ioe.toString());
+    }
+  }
+
+/**
+ Reads the next byte of data from this input stream.
+ */
+  public synchronized int read() throws java.io.IOException{
+    
+    try{
+     
+      long startTime = System.currentTimeMillis();
+    
+      int byte_read = orig_in.read();
+      if ((doCache) && (byte_read != -1)){
+      
+	long cacheStartTime = System.currentTimeMillis();
+	((FileCacheData)filecache.get(my_file_url)).copyData((byte)byte_read);
+	long cacheEndTime = System.currentTimeMillis();
+	Cachingtime += (cacheEndTime - cacheStartTime);
+      }
+    
+      long endTime = System.currentTimeMillis();
+      long totalTime = endTime - startTime;
+
+
+      IOtime += totalTime;
+    
+      if( debug ){
+//        System.out.println("byte_read = " + byte_read);
+      }
+
+      collectReadStats(1);
+      return byte_read;
+    
+    }catch(java.io.IOException ioe){
+      printStackTrace(ioe);
+      throw new StopBenchmarkException(ioe.toString());
+    }
+  }
+
+/**
+ Reads up to byte.length bytes of data from this input stream into an array of 
+ bytes. This method blocks until some input is available. 
+	
+ The read method of FilterInputStream calls the read method of three arguments
+ with the arguments b, 0, and b.length, and returns whatever value that method
+ returns. 
+	
+ Note that this method does not call the one-argument read method of its 
+ underlying stream with the single argument b. Subclasses of FilterInputStream
+ do not need to override this method if they have overridden the three-argument
+ read method. 
+ @param b Buffer into which the data is read
+*/    
+  public int read(byte b[]) throws java.io.IOException{
+  
+    try{
+      long startTime = System.currentTimeMillis();
+   
+      int bytes_read = orig_in.read(b);
+    
+      if ((doCache) && (bytes_read > 0)){
+
+	long cacheStartTime = System.currentTimeMillis();
+	((FileCacheData)filecache.get(my_file_url)).copyData(b, 0, bytes_read);
+	long cacheEndTime = System.currentTimeMillis();
+	Cachingtime += (cacheEndTime - cacheStartTime);
+      }
+    
+      long endTime = System.currentTimeMillis();
+      long totalTime = endTime - startTime;
+
+
+      IOtime += totalTime;
+    
+    
+      if( debug ){
+	System.out.println("bytes_read = " + bytes_read);
+      }
+ 
+      collectReadStats(bytes_read);
+      return bytes_read;
+    }catch(java.io.IOException ioe){
+      printStackTrace(ioe);
+      throw new StopBenchmarkException(ioe.toString());
+    }
+  }
+
+/**
+ Reads up to len bytes of data from this input stream into an array of bytes. 
+ This method blocks until some input is available. 
+
+ The read method of FilterInputStream calls the read method of its underlying 
+ input stream with the same arguments and returns whatever value that method 
+ returns. 
+ @param b - the buffer into which the data is read
+ @param off - the start offset of the data
+ @param len - the maximum number of bytes read
+ */ 
+
+  public synchronized int read(byte b[], int off, int len) throws java.io.IOException{
+				 
+				 
+    try{
+     
+      long startTime = System.currentTimeMillis();
+    
+      int bytes_read = orig_in.read(b, off, len);
+      if ((doCache) && (bytes_read > 0)){
+      
+	long cacheStartTime = System.currentTimeMillis();
+	((FileCacheData)filecache.get(my_file_url)).copyData(b, off, bytes_read);
+	long cacheEndTime = System.currentTimeMillis();
+	Cachingtime += (cacheEndTime - cacheStartTime);
+      }
+      long endTime = System.currentTimeMillis();
+      long totalTime = endTime - startTime;
+
+
+      IOtime += totalTime;
+    
+    
+      if( debug ){
+        System.out.println("bytes_read = " + bytes_read);
+      }
+    
+      collectReadStats(bytes_read);
+      return bytes_read;
+   
+    }catch(java.io.IOException ioe){
+      printStackTrace(ioe);
+      throw new StopBenchmarkException(ioe.toString());
+    }
+  }
+
+/**
+ Closes this input stream and releases any system resources associated with the 
+ stream. The close method of FilterInputStream calls the close method of its 
+ underlying input stream. 
+ */
+  public void close() throws java.io.IOException{
+    
+    try{
+      if (!closed){
+
+	orig_in.close();
+	numofCloses ++;
+	num_open_files--;
+    
+	
+	if (debug || testing){
+	  System.out.println("++++++++Closing InputStream for " + my_file_url + 
+	    " " + num_open_files + " " + numofCloses);
+	}
+     
+	closed = true;
+       
+      }
+      else{
+	if (debug){
+	  System.out.println("++++++++InputStream for " + my_file_url + " has been closed before");
+	}
+      }
+    }catch(java.io.IOException ioe){
+      printStackTrace(ioe);
+      throw new StopBenchmarkException(ioe.toString());
+    } 
+    
+  }
+
+/**
+ Skips over and discards n bytes of data from the input stream. The skip method
+ may, for a variety of reasons, end up skipping over some smaller number of 
+ bytes, possibly 0. The actual number of bytes skipped is returned. 
+
+ The skip method of FilterInputStream calls the skip method of its underlying
+ input stream with the same argument, and returns whatever value that method 
+ does. 
+ @param n - number of bytes to be skipped
+ */    
+  public long skip(long n) throws java.io.IOException{
+  
+    try{
+      if (debug){
+	System.out.println("++++++++ Skipping " + n + " positions in InputStream for " + my_file_url);
+      }
+
+      if (doCache){
+	((FileCacheData)filecache.get(my_file_url)).skipPos(n);
+      }
+      return orig_in.skip(n);
+    }catch(java.io.IOException ioe){
+      printStackTrace(ioe);
+      throw new StopBenchmarkException(ioe.toString());
+    } 
+
+  }
+
+  /** 
+   Finalization method.
+   */
+    
+  protected void finalize() throws java.io.IOException{
+    
+  //  try{
+      if (!closed){
+
+	if (debug || testing ){
+	  System.out.println("++++++++Calling close Inside finalize for " + my_file_url );
+	}
+
+	this.close();
+	
+      }
+  /*  }catch(java.io.IOException ioe){
+      printStackTrace(ioe);
+      throw new StopBenchmarkException(ioe.toString());
+    }   
+  */  
+    
+  }
+
+}
diff -Nu mpegaudio1/FileOutputStream.java mpegaudio/FileOutputStream.java
--- mpegaudio1/FileOutputStream.java	Thu Jan  1 01:00:00 1970
+++ mpegaudio/FileOutputStream.java	Tue Nov 26 11:36:25 2002
@@ -0,0 +1,128 @@
+/*
+ * @(#)FileOutputStream.java	1.11 06/17/98
+ *
+ * Copyright (c) 1998 Standard Performance Evaluation Corporation (SPEC)
+ *               All rights reserved.
+ * Copyright (c) 1997,1998 Sun Microsystems, Inc. All rights reserved.
+ *
+ * This source code is provided as is, without any express or implied warranty.
+ */
+
+package spec.io;
+import spec.harness.Context;
+
+/**
+ * Dummy output stream that is only used as a place holder and for a little
+ * benchmark validity checking
+ */ 
+public class FileOutputStream extends java.io.OutputStream {
+
+    /**
+     * Development debug flag
+     */
+    final static boolean debug = false;
+    
+    /**
+     * Count of bytes written
+     */
+    static int byteCount = -99999999;
+    
+    /**
+     * Checksum
+     */
+    static int checksum = 0;
+
+    /** 
+     * Standard constructor. It creates the file if it is not existing, but it
+	 * truncates the existing data if the file already exists
+     */
+    public FileOutputStream(String name) throws java.io.IOException{
+    }
+  
+    /** 
+     * Standard constructor. It opens the existing file but doesn't truncate
+	 * existing data
+	 * @see java.io.FileOutPutStream
+     */
+    public FileOutputStream(String name, boolean append) throws java.io.IOException {
+    }
+
+    /** 
+     * Standard constructor
+     */
+    public FileOutputStream(spec.io.File file) throws java.io.IOException {
+    }
+ 
+    /** 
+     * Writes specified byte into output stream.
+	 * @param b - byte to be written
+     */
+    public void write(int b) throws java.io.IOException {   
+	 byteCount++;
+	 checksum += specialTrace("W", b ); 
+    }
+
+    /** 
+     * Write b.length bytes into output stream
+	 * @param b - byte array to be written
+     */
+    public void write(byte b[]) throws java.io.IOException {
+	int len = b.length;    
+	byteCount += len;
+	if (len > 0) {
+   	    checksum += specialTrace("X", b[0] );; // Just checksum the first character
+	}	
+	if( debug ) {
+            System.out.println("Inside spec.io.FileOutStream.write() -- throwing away output");
+	}
+    }
+
+/** 
+ Writes len bytes from the specified byte array starting at offset off to this 
+ output stream. The write method of FilterOutputStream calls the write method 
+ of one argument on each byte to output. 
+
+ Note that this method does not call the write method of its underlying input 
+ stream with the same arguments. Subclasses of FilterOutputStream should 
+ provide a more efficient implementation of this method
+*/
+    public void write(byte b[], int off, int len) throws java.io.IOException {
+	byteCount += len;
+
+	if (len > 0) {
+   	    checksum += specialTrace("Z",b[off]); // Just checksum the first character
+	}	
+	if( debug ) {    
+            System.out.println("Inside spec.io.FileOutStream.write() -- throwing away output");
+	}
+    }
+    
+    /** 
+     * Chears the byte counter
+     */    
+    public static void clearCount() {
+	byteCount = 0;
+	checksum  = 0;
+    }
+
+    /** 
+     * Prints the byte counter in validity check mode '1'
+	 * @param check - Indicates whether the validation is enabled or not
+     */
+    public static void printCount(boolean check) {
+        spec.io.PrintStream s = (spec.io.PrintStream)Context.out;
+        if( check ) {
+  	    s.println('1',"File output byte count = "+byteCount+" checksum = "+checksum);
+        } else {  	
+  	    s.println('1',"File output byte count = "+byteCount);
+  	}
+    }
+    
+
+    public static int specialTrace(String rtn, int ch) {
+//	((spec.io.PrintStream)Context.out).println('1',rtn+ch);
+	return ch;
+    }    
+}
+  
+		      
diff -Nu mpegaudio1/StopBenchmarkException.java mpegaudio/StopBenchmarkException.java
--- mpegaudio1/StopBenchmarkException.java	Thu Jan  1 01:00:00 1970
+++ mpegaudio/StopBenchmarkException.java	Tue Nov 26 11:31:12 2002
@@ -0,0 +1,9 @@
+package spec.io;
+
+import java.io.IOException;
+
+class StopBenchmarkException extends IOException {
+    public StopBenchmarkException(String a) {
+	super(a);
+    }
+};
diff -Nu mpegaudio1/TableOfExistingFiles.java mpegaudio/TableOfExistingFiles.java
--- mpegaudio1/TableOfExistingFiles.java	Thu Jan  1 01:00:00 1970
+++ mpegaudio/TableOfExistingFiles.java	Tue Nov 26 11:03:06 2002
@@ -0,0 +1,672 @@
+/*
+ * @(#)TableOfExistingFiles.java	1.5 06/17/98
+ *
+ * Copyright (c) 1998 Standard Performance Evaluation Corporation (SPEC)
+ *               All rights reserved.
+ * Copyright (c) 1997,1998 Sun Microsystems, Inc. All rights reserved.
+ *
+ * This source code is provided as is, without any express or implied warranty.
+ */
+
+package spec.io;
+
+/**
+ This class maintains a list of the files that should not be loaded across
+ the net. Any other class or data file required by the SpecJVMClient are
+ loaded across the net.
+ */
+public class TableOfExistingFiles extends java.util.Hashtable{
+
+/**
+ Constructor. 
+ */
+public TableOfExistingFiles(){
+super();
+
+String o = "Java programmers make better lovers.";
+super.put("lib/java/util" , o);
+super.put("lib/java/io" , o);
+super.put("lib/java/lang/Object.class" , o);
+super.put("lib/java/lang/Exception.class" , o);
+super.put("lib/java/lang/Integer.class" , o);
+super.put("lib/java/lang/NumberFormatException.class" , o);
+super.put("lib/java/lang/Throwable.class" , o);
+super.put("lib/java/lang/Class.class" , o);
+super.put("lib/java/lang/IllegalAccessException.class" , o);
+super.put("lib/java/lang/StringBuffer.class" , o);
+super.put("lib/java/lang/ClassNotFoundException.class" , o);
+super.put("lib/java/lang/IllegalArgumentException.class" , o);
+super.put("lib/java/lang/Number.class" , o);
+super.put("lib/java/lang/InterruptedException.class" , o);
+super.put("lib/java/lang/String.class" , o);
+super.put("lib/java/lang/RuntimeException.class" , o);
+super.put("lib/java/lang/InternalError.class" , o);
+super.put("lib/java/lang/Long.class" , o);
+super.put("lib/java/lang/Character.class" , o);
+super.put("lib/java/lang/CloneNotSupportedException.class" , o);
+super.put("lib/java/lang/InstantiationException.class" , o);
+super.put("lib/java/lang/VirtualMachineError.class" , o);
+super.put("lib/java/lang/Double.class" , o);
+super.put("lib/java/lang/Error.class" , o);
+super.put("lib/java/lang/NullPointerException.class" , o);
+super.put("lib/java/lang/Cloneable.class" , o);
+super.put("lib/java/lang/System.class" , o);
+super.put("lib/java/lang/ClassLoader.class" , o);
+super.put("lib/java/lang/Math.class" , o);
+super.put("lib/java/lang/Float.class" , o);
+super.put("lib/java/lang/Runtime.class" , o);
+super.put("lib/java/lang/StringIndexOutOfBoundsException.class" , o);
+super.put("lib/java/lang/IndexOutOfBoundsException.class" , o);
+super.put("lib/java/lang/SecurityException.class" , o);
+super.put("lib/java/lang/LinkageError.class" , o);
+super.put("lib/java/lang/Runnable.class" , o);
+super.put("lib/java/lang/Process.class" , o);
+super.put("lib/java/lang/SecurityManager.class" , o);
+super.put("lib/java/lang/Thread.class" , o);
+super.put("lib/java/lang/UnsatisfiedLinkError.class" , o);
+super.put("lib/java/lang/IncompatibleClassChangeError.class" , o);
+super.put("lib/java/lang/NoSuchMethodError.class" , o);
+super.put("lib/java/lang/IllegalThreadStateException.class" , o);
+super.put("lib/java/lang/ThreadGroup.class" , o);
+super.put("lib/java/lang/ThreadDeath.class" , o);
+super.put("lib/java/lang/ArrayIndexOutOfBoundsException.class" , o);
+super.put("lib/java/lang/Boolean.class" , o);
+super.put("lib/java/lang/Compiler.class" , o);
+super.put("lib/java/lang/NoSuchMethodException.class" , o);
+super.put("lib/java/lang/ArithmeticException.class" , o);
+super.put("lib/java/lang/ArrayStoreException.class" , o);
+super.put("lib/java/lang/ClassCastException.class" , o);
+super.put("lib/java/lang/NegativeArraySizeException.class" , o);
+super.put("lib/java/lang/IllegalMonitorStateException.class" , o);
+super.put("lib/java/lang/ClassCircularityError.class" , o);
+super.put("lib/java/lang/ClassFormatError.class" , o);
+super.put("lib/java/lang/AbstractMethodError.class" , o);
+super.put("lib/java/lang/IllegalAccessError.class" , o);
+super.put("lib/java/lang/InstantiationError.class" , o);
+super.put("lib/java/lang/NoSuchFieldError.class" , o);
+super.put("lib/java/lang/NoClassDefFoundError.class" , o);
+super.put("lib/java/lang/VerifyError.class" , o);
+super.put("lib/java/lang/OutOfMemoryError.class" , o);
+super.put("lib/java/lang/StackOverflowError.class" , o);
+super.put("lib/java/lang/UnknownError.class" , o);
+super.put("lib/java/lang/Win32Process.class" , o);
+super.put("lib/java/io/FilterOutputStream.class" , o);
+super.put("lib/java/io/OutputStream.class" , o);
+super.put("lib/java/io/IOException.class" , o);
+super.put("lib/java/io/PrintStream.class" , o);
+super.put("lib/java/io/FileInputStream.class" , o);
+super.put("lib/java/io/InterruptedIOException.class" , o);
+super.put("lib/java/io/File.class" , o);
+super.put("lib/java/io/InputStream.class" , o);
+super.put("lib/java/io/BufferedInputStream.class" , o);
+super.put("lib/java/io/FileOutputStream.class" , o);
+super.put("lib/java/io/FileNotFoundException.class" , o);
+super.put("lib/java/io/BufferedOutputStream.class" , o);
+super.put("lib/java/io/FileDescriptor.class" , o);
+super.put("lib/java/io/FilenameFilter.class" , o);
+super.put("lib/java/io/FilterInputStream.class" , o);
+super.put("lib/java/io/PipedInputStream.class" , o);
+super.put("lib/java/io/PipedOutputStream.class" , o);
+super.put("lib/java/io/EOFException.class" , o);
+super.put("lib/java/io/UTFDataFormatException.class" , o);
+super.put("lib/java/io/DataInput.class" , o);
+super.put("lib/java/io/DataOutput.class" , o);
+super.put("lib/java/io/DataInputStream.class" , o);
+super.put("lib/java/io/PushbackInputStream.class" , o);
+super.put("lib/java/io/ByteArrayInputStream.class" , o);
+super.put("lib/java/io/SequenceInputStream.class" , o);
+super.put("lib/java/io/StringBufferInputStream.class" , o);
+super.put("lib/java/io/LineNumberInputStream.class" , o);
+super.put("lib/java/io/DataOutputStream.class" , o);
+super.put("lib/java/io/ByteArrayOutputStream.class" , o);
+super.put("lib/java/io/RandomAccessFile.class" , o);
+super.put("lib/java/io/StreamTokenizer.class" , o);
+super.put("lib/java/util/Hashtable.class" , o);
+super.put("lib/java/util/Enumeration.class" , o);
+super.put("lib/java/util/HashtableEnumerator.class" , o);
+super.put("lib/java/util/Properties.class" , o);
+super.put("lib/java/util/HashtableEntry.class" , o);
+super.put("lib/java/util/Dictionary.class" , o);
+super.put("lib/java/util/Date.class" , o);
+super.put("lib/java/util/NoSuchElementException.class" , o);
+super.put("lib/java/util/StringTokenizer.class" , o);
+super.put("lib/java/util/Random.class" , o);
+super.put("lib/java/util/VectorEnumerator.class" , o);
+super.put("lib/java/util/Vector.class" , o);
+super.put("lib/java/util/BitSet.class" , o);
+super.put("lib/java/util/EmptyStackException.class" , o);
+super.put("lib/java/util/Observable.class" , o);
+super.put("lib/java/util/Observer.class" , o);
+super.put("lib/java/util/ObserverList.class" , o);
+super.put("lib/java/util/Stack.class" , o);
+super.put("lib/java/awt/Toolkit.class" , o);
+super.put("lib/java/awt/peer/WindowPeer.class" , o);
+super.put("lib/java/awt/peer/TextFieldPeer.class" , o);
+super.put("lib/java/awt/peer/ContainerPeer.class" , o);
+super.put("lib/java/awt/peer/PanelPeer.class" , o);
+super.put("lib/java/awt/peer/CanvasPeer.class" , o);
+super.put("lib/java/awt/peer/FramePeer.class" , o);
+super.put("lib/java/awt/peer/ChoicePeer.class" , o);
+super.put("lib/java/awt/peer/CheckboxMenuItemPeer.class" , o);
+super.put("lib/java/awt/peer/TextAreaPeer.class" , o);
+super.put("lib/java/awt/peer/FileDialogPeer.class" , o);
+super.put("lib/java/awt/peer/TextComponentPeer.class" , o);
+super.put("lib/java/awt/peer/ScrollbarPeer.class" , o);
+super.put("lib/java/awt/peer/ButtonPeer.class" , o);
+super.put("lib/java/awt/peer/ComponentPeer.class" , o);
+super.put("lib/java/awt/peer/MenuComponentPeer.class" , o);
+super.put("lib/java/awt/peer/MenuItemPeer.class" , o);
+super.put("lib/java/awt/peer/CheckboxPeer.class" , o);
+super.put("lib/java/awt/peer/MenuPeer.class" , o);
+super.put("lib/java/awt/peer/ListPeer.class" , o);
+super.put("lib/java/awt/peer/MenuBarPeer.class" , o);
+super.put("lib/java/awt/peer/LabelPeer.class" , o);
+super.put("lib/java/awt/peer/DialogPeer.class" , o);
+super.put("lib/java/awt/Image.class" , o);
+super.put("lib/java/awt/MenuItem.class" , o);
+super.put("lib/java/awt/MenuComponent.class" , o);
+super.put("lib/java/awt/image/ImageProducer.class" , o);
+super.put("lib/java/awt/image/ColorModel.class" , o);
+super.put("lib/java/awt/image/DirectColorModel.class" , o);
+super.put("lib/java/awt/image/ImageConsumer.class" , o);
+super.put("lib/java/awt/image/ImageObserver.class" , o);
+super.put("lib/java/awt/image/CropImageFilter.class" , o);
+super.put("lib/java/awt/image/ImageFilter.class" , o);
+super.put("lib/java/awt/image/FilteredImageSource.class" , o);
+super.put("lib/java/awt/image/IndexColorModel.class" , o);
+super.put("lib/java/awt/image/MemoryImageSource.class" , o);
+super.put("lib/java/awt/image/PixelGrabber.class" , o);
+super.put("lib/java/awt/image/RGBImageFilter.class" , o);
+super.put("lib/java/awt/FontMetrics.class" , o);
+super.put("lib/java/awt/Checkbox.class" , o);
+super.put("lib/java/awt/CheckboxGroup.class" , o);
+super.put("lib/java/awt/MenuContainer.class" , o);
+super.put("lib/java/awt/Menu.class" , o);
+super.put("lib/java/awt/Insets.class" , o);
+super.put("lib/java/awt/MenuBar.class" , o);
+super.put("lib/java/awt/List.class" , o);
+super.put("lib/java/awt/Label.class" , o);
+super.put("lib/java/awt/Component.class" , o);
+super.put("lib/java/awt/TextField.class" , o);
+super.put("lib/java/awt/TextComponent.class" , o);
+super.put("lib/java/awt/Dialog.class" , o);
+super.put("lib/java/awt/Font.class" , o);
+super.put("lib/java/awt/Window.class" , o);
+super.put("lib/java/awt/FocusManager.class" , o);
+super.put("lib/java/awt/Panel.class" , o);
+super.put("lib/java/awt/Container.class" , o);
+super.put("lib/java/awt/Graphics.class" , o);
+super.put("lib/java/awt/CheckboxMenuItem.class" , o);
+super.put("lib/java/awt/Canvas.class" , o);
+super.put("lib/java/awt/Frame.class" , o);
+super.put("lib/java/awt/Choice.class" , o);
+super.put("lib/java/awt/Event.class" , o);
+super.put("lib/java/awt/TextArea.class" , o);
+super.put("lib/java/awt/AWTError.class" , o);
+super.put("lib/java/awt/Polygon.class" , o);
+super.put("lib/java/awt/FlowLayout.class" , o);
+super.put("lib/java/awt/Point.class" , o);
+super.put("lib/java/awt/FileDialog.class" , o);
+super.put("lib/java/awt/Scrollbar.class" , o);
+super.put("lib/java/awt/Dimension.class" , o);
+super.put("lib/java/awt/Color.class" , o);
+super.put("lib/java/awt/Button.class" , o);
+super.put("lib/java/awt/LayoutManager.class" , o);
+super.put("lib/java/awt/Rectangle.class" , o);
+super.put("lib/java/awt/BorderLayout.class" , o);
+super.put("lib/java/awt/GridLayout.class" , o);
+super.put("lib/java/awt/GridBagConstraints.class" , o);
+super.put("lib/java/awt/GridBagLayout.class" , o);
+super.put("lib/java/awt/GridBagLayoutInfo.class" , o);
+super.put("lib/java/awt/CardLayout.class" , o);
+super.put("lib/java/awt/MediaTracker.class" , o);
+super.put("lib/java/awt/MediaEntry.class" , o);
+super.put("lib/java/awt/ImageMediaEntry.class" , o);
+super.put("lib/java/awt/AWTException.class" , o);
+super.put("lib/java/net/URL.class" , o);
+super.put("lib/java/net/URLStreamHandlerFactory.class" , o);
+super.put("lib/java/net/InetAddress.class" , o);
+super.put("lib/java/net/UnknownContentHandler.class" , o);
+super.put("lib/java/net/UnknownHostException.class" , o);
+super.put("lib/java/net/URLStreamHandler.class" , o);
+super.put("lib/java/net/URLConnection.class" , o);
+super.put("lib/java/net/MalformedURLException.class" , o);
+super.put("lib/java/net/ContentHandlerFactory.class" , o);
+super.put("lib/java/net/ContentHandler.class" , o);
+super.put("lib/java/net/UnknownServiceException.class" , o);
+super.put("lib/java/net/ServerSocket.class" , o);
+super.put("lib/java/net/PlainSocketImpl.class" , o);
+super.put("lib/java/net/SocketImpl.class" , o);
+super.put("lib/java/net/ProtocolException.class" , o);
+super.put("lib/java/net/SocketException.class" , o);
+super.put("lib/java/net/SocketInputStream.class" , o);
+super.put("lib/java/net/Socket.class" , o);
+super.put("lib/java/net/SocketImplFactory.class" , o);
+super.put("lib/java/net/SocketOutputStream.class" , o);
+super.put("lib/java/net/DatagramPacket.class" , o);
+super.put("lib/java/net/DatagramSocket.class" , o);
+super.put("lib/java/net/URLEncoder.class" , o);
+super.put("lib/java/applet/Applet.class" , o);
+super.put("lib/java/applet/AppletContext.class" , o);
+super.put("lib/java/applet/AudioClip.class" , o);
+super.put("lib/java/applet/AppletStub.class" , o);
+super.put("lib/sun/tools/debug/BreakpointQueue.class" , o);
+super.put("lib/sun/tools/debug/DebuggerCallback.class" , o);
+super.put("lib/sun/tools/debug/RemoteThread.class" , o);
+super.put("lib/sun/tools/debug/StackFrame.class" , o);
+super.put("lib/sun/tools/debug/RemoteAgent.class" , o);
+super.put("lib/sun/tools/debug/AgentConstants.class" , o);
+super.put("lib/sun/tools/debug/AgentIn.class" , o);
+super.put("lib/sun/tools/debug/RemoteObject.class" , o);
+super.put("lib/sun/tools/debug/RemoteStackVariable.class" , o);
+super.put("lib/sun/tools/debug/RemoteValue.class" , o);
+super.put("lib/sun/tools/debug/RemoteClass.class" , o);
+super.put("lib/sun/tools/debug/Agent.class" , o);
+super.put("lib/sun/tools/debug/RemoteBoolean.class" , o);
+super.put("lib/sun/tools/debug/RemoteChar.class" , o);
+super.put("lib/sun/tools/debug/RemoteString.class" , o);
+super.put("lib/sun/tools/debug/NoSessionException.class" , o);
+super.put("lib/sun/tools/debug/Field.class" , o);
+super.put("lib/sun/tools/debug/NoSuchLineNumberException.class" , o);
+super.put("lib/sun/tools/debug/RemoteShort.class" , o);
+super.put("lib/sun/tools/debug/RemoteThreadGroup.class" , o);
+super.put("lib/sun/tools/debug/RemoteInt.class" , o);
+super.put("lib/sun/tools/debug/ResponseStream.class" , o);
+super.put("lib/sun/tools/debug/RemoteDouble.class" , o);
+super.put("lib/sun/tools/debug/LocalVariable.class" , o);
+super.put("lib/sun/tools/debug/BreakpointSet.class" , o);
+super.put("lib/sun/tools/debug/RemoteStackFrame.class" , o);
+super.put("lib/sun/tools/debug/MainThread.class" , o);
+super.put("lib/sun/tools/debug/BreakpointHandler.class" , o);
+super.put("lib/sun/tools/debug/AgentOutputStream.class" , o);
+super.put("lib/sun/tools/debug/RemoteLong.class" , o);
+super.put("lib/sun/tools/debug/RemoteFloat.class" , o);
+super.put("lib/sun/tools/debug/RemoteArray.class" , o);
+super.put("lib/sun/tools/debug/InvalidPCException.class" , o);
+super.put("lib/sun/tools/debug/LineNumber.class" , o);
+super.put("lib/sun/tools/debug/RemoteField.class" , o);
+super.put("lib/sun/tools/debug/NoSuchFieldException.class" , o);
+super.put("lib/sun/tools/debug/RemoteByte.class" , o);
+super.put("lib/sun/tools/debug/EmptyApp.class" , o);
+super.put("lib/sun/tools/debug/RemoteDebugger.class" , o);
+super.put("lib/sun/tools/java/RuntimeConstants.class" , o);
+super.put("lib/sun/tools/java/Constants.class" , o);
+super.put("lib/sun/tools/java/Environment.class" , o);
+super.put("lib/sun/tools/java/ClassPath.class" , o);
+super.put("lib/sun/tools/java/ClassDeclaration.class" , o);
+super.put("lib/sun/tools/java/FieldDefinition.class" , o);
+super.put("lib/sun/tools/java/Type.class" , o);
+super.put("lib/sun/tools/java/ClassNotFound.class" , o);
+super.put("lib/sun/tools/java/ClassType.class" , o);
+super.put("lib/sun/tools/java/ClassDefinition.class" , o);
+super.put("lib/sun/tools/java/Parser.class" , o);
+super.put("lib/sun/tools/java/ClassPathEntry.class" , o);
+super.put("lib/sun/tools/java/CompilerError.class" , o);
+super.put("lib/sun/tools/java/Identifier.class" , o);
+super.put("lib/sun/tools/java/Package.class" , o);
+super.put("lib/sun/tools/java/ClassFile.class" , o);
+super.put("lib/sun/tools/java/Imports.class" , o);
+super.put("lib/sun/tools/java/ArrayType.class" , o);
+super.put("lib/sun/tools/java/AmbiguousField.class" , o);
+super.put("lib/sun/tools/java/MethodType.class" , o);
+super.put("lib/sun/tools/java/Scanner.class" , o);
+super.put("lib/sun/tools/java/SyntaxError.class" , o);
+super.put("lib/sun/tools/java/BinaryClass.class" , o);
+super.put("lib/sun/tools/java/BinaryField.class" , o);
+super.put("lib/sun/tools/java/AmbiguousClass.class" , o);
+super.put("lib/sun/tools/java/BinaryConstantPool.class" , o);
+super.put("lib/sun/tools/java/ScannerInputStream.class" , o);
+super.put("lib/sun/tools/java/BinaryAttribute.class" , o);
+super.put("lib/sun/tools/java/BinaryCode.class" , o);
+super.put("lib/sun/tools/java/BinaryExceptionHandler.class" , o);
+super.put("lib/sun/tools/javac/Main.class" , o);
+super.put("lib/sun/tools/javac/SourceClass.class" , o);
+super.put("lib/sun/tools/javac/CompilerField.class" , o);
+super.put("lib/sun/tools/javac/SourceField.class" , o);
+super.put("lib/sun/tools/javac/BatchEnvironment.class" , o);
+super.put("lib/sun/tools/javac/ErrorConsumer.class" , o);
+super.put("lib/sun/tools/javac/ErrorMessage.class" , o);
+super.put("lib/sun/tools/javac/BatchParser.class" , o);
+super.put("lib/sun/tools/zip/ZipFile.class" , o);
+super.put("lib/sun/tools/zip/ZipEntry.class" , o);
+super.put("lib/sun/tools/zip/ZipFileInputStream.class" , o);
+super.put("lib/sun/tools/zip/ZipConstants.class" , o);
+super.put("lib/sun/tools/zip/ZipFormatException.class" , o);
+super.put("lib/sun/tools/zip/ZipReaderInputStream.class" , o);
+super.put("lib/sun/tools/zip/ZipReader.class" , o);
+super.put("lib/sun/tools/tree/ConstantExpression.class" , o);
+super.put("lib/sun/tools/tree/LocalField.class" , o);
+super.put("lib/sun/tools/tree/Expression.class" , o);
+super.put("lib/sun/tools/tree/IncDecExpression.class" , o);
+super.put("lib/sun/tools/tree/SuperExpression.class" , o);
+super.put("lib/sun/tools/tree/NaryExpression.class" , o);
+super.put("lib/sun/tools/tree/StringExpression.class" , o);
+super.put("lib/sun/tools/tree/UnaryExpression.class" , o);
+super.put("lib/sun/tools/tree/Context.class" , o);
+super.put("lib/sun/tools/tree/ExpressionStatement.class" , o);
+super.put("lib/sun/tools/tree/ConditionVars.class" , o);
+super.put("lib/sun/tools/tree/Node.class" , o);
+super.put("lib/sun/tools/tree/CharExpression.class" , o);
+super.put("lib/sun/tools/tree/CaseStatement.class" , o);
+super.put("lib/sun/tools/tree/LessExpression.class" , o);
+super.put("lib/sun/tools/tree/IntegerExpression.class" , o);
+super.put("lib/sun/tools/tree/SubtractExpression.class" , o);
+super.put("lib/sun/tools/tree/ArrayAccessExpression.class" , o);
+super.put("lib/sun/tools/tree/TryStatement.class" , o);
+super.put("lib/sun/tools/tree/BinaryEqualityExpression.class" , o);
+super.put("lib/sun/tools/tree/Statement.class" , o);
+super.put("lib/sun/tools/tree/AssignSubtractExpression.class" , o);
+super.put("lib/sun/tools/tree/FinallyStatement.class" , o);
+super.put("lib/sun/tools/tree/ForStatement.class" , o);
+super.put("lib/sun/tools/tree/DivRemExpression.class" , o);
+super.put("lib/sun/tools/tree/BinaryExpression.class" , o);
+super.put("lib/sun/tools/tree/ShiftRightExpression.class" , o);
+super.put("lib/sun/tools/tree/AssignMultiplyExpression.class" , o);
+super.put("lib/sun/tools/tree/BooleanExpression.class" , o);
+super.put("lib/sun/tools/tree/BinaryArithmeticExpression.class" , o);
+super.put("lib/sun/tools/tree/ThrowStatement.class" , o);
+super.put("lib/sun/tools/tree/AssignDivideExpression.class" , o);
+super.put("lib/sun/tools/tree/AssignShiftLeftExpression.class" , o);
+super.put("lib/sun/tools/tree/NewArrayExpression.class" , o);
+super.put("lib/sun/tools/tree/AndExpression.class" , o);
+super.put("lib/sun/tools/tree/AssignBitOrExpression.class" , o);
+super.put("lib/sun/tools/tree/BreakStatement.class" , o);
+super.put("lib/sun/tools/tree/SynchronizedStatement.class" , o);
+super.put("lib/sun/tools/tree/PreDecExpression.class" , o);
+super.put("lib/sun/tools/tree/CompoundStatement.class" , o);
+super.put("lib/sun/tools/tree/DoubleExpression.class" , o);
+super.put("lib/sun/tools/tree/ConvertExpression.class" , o);
+super.put("lib/sun/tools/tree/NullExpression.class" , o);
+super.put("lib/sun/tools/tree/LessOrEqualExpression.class" , o);
+super.put("lib/sun/tools/tree/IdentifierExpression.class" , o);
+super.put("lib/sun/tools/tree/ReturnStatement.class" , o);
+super.put("lib/sun/tools/tree/BitNotExpression.class" , o);
+super.put("lib/sun/tools/tree/LongExpression.class" , o);
+super.put("lib/sun/tools/tree/VarDeclarationStatement.class" , o);
+super.put("lib/sun/tools/tree/MethodExpression.class" , o);
+super.put("lib/sun/tools/tree/ThisExpression.class" , o);
+super.put("lib/sun/tools/tree/BitOrExpression.class" , o);
+super.put("lib/sun/tools/tree/PositiveExpression.class" , o);
+super.put("lib/sun/tools/tree/IfStatement.class" , o);
+super.put("lib/sun/tools/tree/FloatExpression.class" , o);
+super.put("lib/sun/tools/tree/NotEqualExpression.class" , o);
+super.put("lib/sun/tools/tree/InstanceOfExpression.class" , o);
+super.put("lib/sun/tools/tree/NotExpression.class" , o);
+super.put("lib/sun/tools/tree/BitAndExpression.class" , o);
+super.put("lib/sun/tools/tree/DivideExpression.class" , o);
+super.put("lib/sun/tools/tree/ShortExpression.class" , o);
+super.put("lib/sun/tools/tree/RemainderExpression.class" , o);
+super.put("lib/sun/tools/tree/NewInstanceExpression.class" , o);
+super.put("lib/sun/tools/tree/SwitchStatement.class" , o);
+super.put("lib/sun/tools/tree/AddExpression.class" , o);
+super.put("lib/sun/tools/tree/AssignOpExpression.class" , o);
+super.put("lib/sun/tools/tree/EqualExpression.class" , o);
+super.put("lib/sun/tools/tree/PostIncExpression.class" , o);
+super.put("lib/sun/tools/tree/GreaterExpression.class" , o);
+super.put("lib/sun/tools/tree/PostDecExpression.class" , o);
+super.put("lib/sun/tools/tree/AssignExpression.class" , o);
+super.put("lib/sun/tools/tree/WhileStatement.class" , o);
+super.put("lib/sun/tools/tree/ContinueStatement.class" , o);
+super.put("lib/sun/tools/tree/ConditionalExpression.class" , o);
+super.put("lib/sun/tools/tree/AssignAddExpression.class" , o);
+super.put("lib/sun/tools/tree/BinaryBitExpression.class" , o);
+super.put("lib/sun/tools/tree/CastExpression.class" , o);
+super.put("lib/sun/tools/tree/AssignBitXorExpression.class" , o);
+super.put("lib/sun/tools/tree/ArrayExpression.class" , o);
+super.put("lib/sun/tools/tree/InlineMethodExpression.class" , o);
+super.put("lib/sun/tools/tree/InlineNewInstanceExpression.class" , o);
+super.put("lib/sun/tools/tree/CodeContext.class" , o);
+super.put("lib/sun/tools/tree/AssignShiftRightExpression.class" , o);
+super.put("lib/sun/tools/tree/UnsignedShiftRightExpression.class" , o);
+super.put("lib/sun/tools/tree/AssignBitAndExpression.class" , o);
+super.put("lib/sun/tools/tree/ShiftLeftExpression.class" , o);
+super.put("lib/sun/tools/tree/CatchStatement.class" , o);
+super.put("lib/sun/tools/tree/IntExpression.class" , o);
+super.put("lib/sun/tools/tree/TypeExpression.class" , o);
+super.put("lib/sun/tools/tree/CommaExpression.class" , o);
+super.put("lib/sun/tools/tree/AssignUnsignedShiftRightExpression.class" , o);
+super.put("lib/sun/tools/tree/ExprExpression.class" , o);
+super.put("lib/sun/tools/tree/AssignRemainderExpression.class" , o);
+super.put("lib/sun/tools/tree/ByteExpression.class" , o);
+super.put("lib/sun/tools/tree/BinaryAssignExpression.class" , o);
+super.put("lib/sun/tools/tree/DoStatement.class" , o);
+super.put("lib/sun/tools/tree/DeclarationStatement.class" , o);
+super.put("lib/sun/tools/tree/MultiplyExpression.class" , o);
+super.put("lib/sun/tools/tree/InlineReturnStatement.class" , o);
+super.put("lib/sun/tools/tree/BitXorExpression.class" , o);
+super.put("lib/sun/tools/tree/BinaryCompareExpression.class" , o);
+super.put("lib/sun/tools/tree/BinaryShiftExpression.class" , o);
+super.put("lib/sun/tools/tree/CheckContext.class" , o);
+super.put("lib/sun/tools/tree/PreIncExpression.class" , o);
+super.put("lib/sun/tools/tree/GreaterOrEqualExpression.class" , o);
+super.put("lib/sun/tools/tree/FieldExpression.class" , o);
+super.put("lib/sun/tools/tree/OrExpression.class" , o);
+super.put("lib/sun/tools/tree/BinaryLogicalExpression.class" , o);
+super.put("lib/sun/tools/tree/NegativeExpression.class" , o);
+super.put("lib/sun/tools/tree/LengthExpression.class" , o);
+super.put("lib/sun/tools/asm/Assembler.class" , o);
+super.put("lib/sun/tools/asm/Instruction.class" , o);
+super.put("lib/sun/tools/asm/LocalVariable.class" , o);
+super.put("lib/sun/tools/asm/ArrayData.class" , o);
+super.put("lib/sun/tools/asm/LocalVariableTable.class" , o);
+super.put("lib/sun/tools/asm/SwitchDataEnumeration.class" , o);
+super.put("lib/sun/tools/asm/ConstantPool.class" , o);
+super.put("lib/sun/tools/asm/ConstantPoolData.class" , o);
+super.put("lib/sun/tools/asm/NameAndTypeConstantData.class" , o);
+super.put("lib/sun/tools/asm/NumberConstantData.class" , o);
+super.put("lib/sun/tools/asm/FieldConstantData.class" , o);
+super.put("lib/sun/tools/asm/TryData.class" , o);
+super.put("lib/sun/tools/asm/Label.class" , o);
+super.put("lib/sun/tools/asm/SwitchData.class" , o);
+super.put("lib/sun/tools/asm/CatchData.class" , o);
+super.put("lib/sun/tools/asm/StringExpressionConstantData.class" , o);
+super.put("lib/sun/tools/asm/NameAndTypeData.class" , o);
+super.put("lib/sun/tools/asm/StringConstantData.class" , o);
+super.put("lib/sun/tools/asm/ClassConstantData.class" , o);
+super.put("lib/sun/tools/ttydebug/TTY.class" , o);
+super.put("lib/sun/tools/javadoc/Main.class" , o);
+super.put("lib/sun/tools/javadoc/DocumentationGenerator.class" , o);
+super.put("lib/sun/tools/javadoc/HTMLDocumentationGenerator.class" , o);
+super.put("lib/sun/tools/javadoc/MIFDocumentationGenerator.class" , o);
+super.put("lib/sun/tools/javadoc/MIFPrintStream.class" , o);
+super.put("lib/sun/net/MulticastSocket.class" , o);
+super.put("lib/sun/net/URLCanonicalizer.class" , o);
+super.put("lib/sun/net/NetworkClient.class" , o);
+super.put("lib/sun/net/NetworkServer.class" , o);
+super.put("lib/sun/net/ProgressData.class" , o);
+super.put("lib/sun/net/ProgressEntry.class" , o);
+super.put("lib/sun/net/TelnetInputStream.class" , o);
+super.put("lib/sun/net/TelnetProtocolException.class" , o);
+super.put("lib/sun/net/TelnetOutputStream.class" , o);
+super.put("lib/sun/net/TransferProtocolClient.class" , o);
+super.put("lib/sun/net/ftp/FtpInputStream.class" , o);
+super.put("lib/sun/net/ftp/FtpClient.class" , o);
+super.put("lib/sun/net/ftp/FtpLoginException.class" , o);
+super.put("lib/sun/net/ftp/FtpProtocolException.class" , o);
+super.put("lib/sun/net/ftp/IftpClient.class" , o);
+super.put("lib/sun/net/nntp/NewsgroupInfo.class" , o);
+super.put("lib/sun/net/nntp/NntpClient.class" , o);
+super.put("lib/sun/net/nntp/UnknownNewsgroupException.class" , o);
+super.put("lib/sun/net/nntp/NntpProtocolException.class" , o);
+super.put("lib/sun/net/nntp/NntpInputStream.class" , o);
+super.put("lib/sun/net/smtp/SmtpPrintStream.class" , o);
+super.put("lib/sun/net/smtp/SmtpClient.class" , o);
+super.put("lib/sun/net/smtp/SmtpProtocolException.class" , o);
+super.put("lib/sun/net/www/auth/Authenticator.class" , o);
+super.put("lib/sun/net/www/auth/basic.class" , o);
+super.put("lib/sun/net/www/content/text/Generic.class" , o);
+super.put("lib/sun/net/www/content/text/plain.class" , o);
+super.put("lib/sun/net/www/content/image/gif.class" , o);
+super.put("lib/sun/net/www/content/image/jpeg.class" , o);
+super.put("lib/sun/net/www/content/image/x_xbitmap.class" , o);
+super.put("lib/sun/net/www/content/image/x_xpixmap.class" , o);
+super.put("lib/sun/net/www/FormatException.class" , o);
+super.put("lib/sun/net/www/MessageHeader.class" , o);
+super.put("lib/sun/net/www/MeteredStream.class" , o);
+super.put("lib/sun/net/www/ProgressReport.class" , o);
+super.put("lib/sun/net/www/MimeEntry.class" , o);
+super.put("lib/sun/net/www/MimeLauncher.class" , o);
+super.put("lib/sun/net/www/MimeTable.class" , o);
+super.put("lib/sun/net/www/URLConnection.class" , o);
+super.put("lib/sun/net/www/UnknownContentException.class" , o);
+super.put("lib/sun/net/www/UnknownContentHandler.class" , o);
+super.put("lib/sun/net/www/protocol/file/Handler.class" , o);
+super.put("lib/sun/net/www/protocol/file/FileURLConnection.class" , o);
+super.put("lib/sun/net/www/protocol/http/Handler.class" , o);
+super.put("lib/sun/net/www/protocol/http/HttpURLConnection.class" , o);
+super.put("lib/sun/net/www/protocol/http/HttpPostBufferStream.class" , o);
+super.put("lib/sun/net/www/protocol/doc/Handler.class" , o);
+super.put("lib/sun/net/www/protocol/verbatim/Handler.class" , o);
+super.put("lib/sun/net/www/protocol/verbatim/VerbatimConnection.class" , o);
+super.put("lib/sun/net/www/protocol/gopher/GopherClient.class" , o);
+super.put("lib/sun/net/www/protocol/gopher/GopherInputStream.class" , o);
+super.put("lib/sun/net/www/http/UnauthorizedHttpRequestException.class" , o);
+super.put("lib/sun/net/www/http/HttpClient.class" , o);
+super.put("lib/sun/net/www/http/AuthenticationInfo.class" , o);
+super.put("lib/sun/awt/HorizBagLayout.class" , o);
+super.put("lib/sun/awt/VerticalBagLayout.class" , o);
+super.put("lib/sun/awt/VariableGridLayout.class" , o);
+super.put("lib/sun/awt/FocusingTextField.class" , o);
+super.put("lib/sun/awt/win32/MToolkit.class" , o);
+super.put("lib/sun/awt/win32/MMenuBarPeer.class" , o);
+super.put("lib/sun/awt/win32/MButtonPeer.class" , o);
+super.put("lib/sun/awt/win32/Win32Image.class" , o);
+super.put("lib/sun/awt/win32/MScrollbarPeer.class" , o);
+super.put("lib/sun/awt/win32/MDialogPeer.class" , o);
+super.put("lib/sun/awt/win32/MCheckboxMenuItemPeer.class" , o);
+super.put("lib/sun/awt/win32/Win32Graphics.class" , o);
+super.put("lib/sun/awt/win32/MListPeer.class" , o);
+super.put("lib/sun/awt/win32/MWindowPeer.class" , o);
+super.put("lib/sun/awt/win32/MMenuItemPeer.class" , o);
+super.put("lib/sun/awt/win32/ModalThread.class" , o);
+super.put("lib/sun/awt/win32/MCanvasPeer.class" , o);
+super.put("lib/sun/awt/win32/MFileDialogPeer.class" , o);
+super.put("lib/sun/awt/win32/MTextAreaPeer.class" , o);
+super.put("lib/sun/awt/win32/MPanelPeer.class" , o);
+super.put("lib/sun/awt/win32/MComponentPeer.class" , o);
+super.put("lib/sun/awt/win32/MCheckboxPeer.class" , o);
+super.put("lib/sun/awt/win32/MLabelPeer.class" , o);
+super.put("lib/sun/awt/win32/Win32FontMetrics.class" , o);
+super.put("lib/sun/awt/win32/MFramePeer.class" , o);
+super.put("lib/sun/awt/win32/MMenuPeer.class" , o);
+super.put("lib/sun/awt/win32/MChoicePeer.class" , o);
+super.put("lib/sun/awt/win32/MTextFieldPeer.class" , o);
+super.put("lib/sun/awt/win32/Win32PrintJob.class" , o);
+super.put("lib/sun/awt/image/URLImageSource.class" , o);
+super.put("lib/sun/awt/image/ImageWatched.class" , o);
+super.put("lib/sun/awt/image/InputStreamImageSource.class" , o);
+super.put("lib/sun/awt/image/ConsumerQueue.class" , o);
+super.put("lib/sun/awt/image/ImageDecoder.class" , o);
+super.put("lib/sun/awt/image/ImageRepresentation.class" , o);
+super.put("lib/sun/awt/image/ImageInfoGrabber.class" , o);
+super.put("lib/sun/awt/image/XbmImageDecoder.class" , o);
+super.put("lib/sun/awt/image/GifImageDecoder.class" , o);
+super.put("lib/sun/awt/image/ImageFetcher.class" , o);
+super.put("lib/sun/awt/image/PixelStore.class" , o);
+super.put("lib/sun/awt/image/JPEGImageDecoder.class" , o);
+super.put("lib/sun/awt/image/PixelStore8.class" , o);
+super.put("lib/sun/awt/image/ImageFetchable.class" , o);
+super.put("lib/sun/awt/image/OffScreenImageSource.class" , o);
+super.put("lib/sun/awt/image/PixelStore32.class" , o);
+super.put("lib/sun/awt/image/ImageFormatException.class" , o);
+super.put("lib/sun/awt/image/FileImageSource.class" , o);
+super.put("lib/sun/awt/image/Image.class" , o);
+super.put("lib/sun/awt/UpdateClient.class" , o);
+super.put("lib/sun/awt/ScreenUpdaterEntry.class" , o);
+super.put("lib/sun/awt/ScreenUpdater.class" , o);
+super.put("lib/sun/misc/Ref.class" , o);
+super.put("lib/sun/misc/MessageUtils.class" , o);
+super.put("lib/sun/misc/Cache.class" , o);
+super.put("lib/sun/misc/CacheEntry.class" , o);
+super.put("lib/sun/misc/CacheEnumerator.class" , o);
+super.put("lib/sun/misc/CEFormatException.class" , o);
+super.put("lib/sun/misc/CEStreamExhausted.class" , o);
+super.put("lib/sun/misc/CRC16.class" , o);
+super.put("lib/sun/misc/CharacterDecoder.class" , o);
+super.put("lib/sun/misc/BASE64Decoder.class" , o);
+super.put("lib/sun/misc/UCDecoder.class" , o);
+super.put("lib/sun/misc/UUDecoder.class" , o);
+super.put("lib/sun/misc/CharacterEncoder.class" , o);
+super.put("lib/sun/misc/BASE64Encoder.class" , o);
+super.put("lib/sun/misc/HexDumpEncoder.class" , o);
+super.put("lib/sun/misc/UCEncoder.class" , o);
+super.put("lib/sun/misc/UUEncoder.class" , o);
+super.put("lib/sun/misc/Timeable.class" , o);
+super.put("lib/sun/misc/TimerTickThread.class" , o);
+super.put("lib/sun/misc/Timer.class" , o);
+super.put("lib/sun/misc/TimerThread.class" , o);
+super.put("lib/sun/misc/ConditionLock.class" , o);
+super.put("lib/sun/misc/Lock.class" , o);
+super.put("lib/sun/audio/AudioDataStream.class" , o);
+super.put("lib/sun/audio/AudioData.class" , o);
+super.put("lib/sun/audio/AudioDevice.class" , o);
+super.put("lib/sun/audio/AudioPlayer.class" , o);
+super.put("lib/sun/audio/AudioStream.class" , o);
+super.put("lib/sun/audio/NativeAudioStream.class" , o);
+super.put("lib/sun/audio/InvalidAudioFormatException.class" , o);
+super.put("lib/sun/audio/AudioTranslatorStream.class" , o);
+super.put("lib/sun/audio/AudioStreamSequence.class" , o);
+super.put("lib/sun/audio/ContinuousAudioDataStream.class" , o);
+super.put("lib/sun/applet/StdAppletViewerFactory.class" , o);
+super.put("lib/sun/applet/TextFrame.class" , o);
+super.put("lib/sun/applet/AppletViewerFactory.class" , o);
+super.put("lib/sun/applet/AppletViewer.class" , o);
+super.put("lib/sun/applet/AppletCopyright.class" , o);
+super.put("lib/sun/applet/AppletAudioClip.class" , o);
+super.put("lib/sun/applet/AppletSecurity.class" , o);
+super.put("lib/sun/applet/AppletThreadGroup.class" , o);
+super.put("lib/sun/applet/AppletClassLoader.class" , o);
+super.put("lib/sun/applet/AppletPanel.class" , o);
+super.put("lib/sun/applet/AppletViewerPanel.class" , o);
+super.put("lib/sun/applet/AppletProps.class" , o);
+super.put("lib/sun/applet/AppletSecurityException.class" , o);
+super.put("lib/sun/applet/AppletZipClassLoader.class" , o);
+super.put("lib/spec/benchmarks/_202_jess/Activation.java" , o);
+super.put("lib/spec/benchmarks/_202_jess/Binding.java" , o);
+super.put("lib/spec/benchmarks/_202_jess/Context.java" , o);
+super.put("lib/spec/benchmarks/_202_jess/ContextState.java" , o);
+super.put("lib/spec/benchmarks/_202_jess/Deffacts.java" , o);
+super.put("lib/spec/benchmarks/_202_jess/Deffunction.java" , o);
+super.put("lib/spec/benchmarks/_202_jess/Defglobal.java" , o);
+super.put("lib/spec/benchmarks/_202_jess/Defrule.java" , o);
+super.put("lib/spec/benchmarks/_202_jess/Deftemplate.java" , o);
+super.put("lib/spec/benchmarks/_202_jess/Fact.java" , o);
+super.put("lib/spec/benchmarks/_202_jess/Funcall.java" , o);
+super.put("lib/spec/benchmarks/_202_jess/GlobalContext.java" , o);
+super.put("lib/spec/benchmarks/_202_jess/Jesp.java" , o);
+super.put("lib/spec/benchmarks/_202_jess/Jess.java" , o);
+super.put("lib/spec/benchmarks/_202_jess/Main.java" , o);
+super.put("lib/spec/benchmarks/_202_jess/Node.java" , o);
+super.put("lib/spec/benchmarks/_202_jess/Node1.java" , o);
+super.put("lib/spec/benchmarks/_202_jess/Node2.java" , o);
+super.put("lib/spec/benchmarks/_202_jess/NodeNot2.java" , o);
+super.put("lib/spec/benchmarks/_202_jess/NodeTerm.java" , o);
+super.put("lib/spec/benchmarks/_202_jess/NullDisplay.java" , o);
+super.put("lib/spec/benchmarks/_202_jess/Pattern.java" , o);
+super.put("lib/spec/benchmarks/_202_jess/RU.java" , o);
+super.put("lib/spec/benchmarks/_202_jess/Rete.java" , o);
+super.put("lib/spec/benchmarks/_202_jess/ReteCompiler.java" , o);
+super.put("lib/spec/benchmarks/_202_jess/ReteDisplay.java" , o);
+super.put("lib/spec/benchmarks/_202_jess/ReteException.java" , o);
+super.put("lib/spec/benchmarks/_202_jess/StringFunctions.java" , o);
+super.put("lib/spec/benchmarks/_202_jess/Successor.java" , o);
+super.put("lib/spec/benchmarks/_202_jess/Test1.java" , o);
+super.put("lib/spec/benchmarks/_202_jess/Test2.java" , o);
+super.put("lib/spec/benchmarks/_202_jess/Token.java" , o);
+super.put("lib/spec/benchmarks/_202_jess/TokenVector.java" , o);
+super.put("lib/spec/benchmarks/_202_jess/Userfunction.java" , o);
+super.put("lib/spec/benchmarks/_202_jess/Value.java" , o);
+super.put("lib/spec/benchmarks/_202_jess/ValueVector.java" , o);
+
+}
+
+/**
+ Checks whether the given file exists in the list of existing files
+ */
+public boolean exists(String filename){
+ 
+//   System.out.println( "*** "+filename+" = "+containsKey(filename) );
+  return containsKey(filename);
+
+}
+}
diff -Nu mpegaudio1/setup.sh mpegaudio/setup.sh
--- mpegaudio1/setup.sh	Thu Jan  1 01:00:00 1970
+++ mpegaudio/setup.sh	Sat Nov 30 18:06:34 2002
@@ -0,0 +1,2 @@
+mkdir -p spec/benchmarks/_222_mpegaudio
+mv *.class spec/benchmarks/_222_mpegaudio
diff -Nu mpegaudio1/PrintStream.java mpegaudio/PrintStream.java
--- mpegaudio1/PrintStream.java	Thu Jan  1 01:00:00 1970
+++ mpegaudio/PrintStream.java	Sat Nov 30 18:13:49 2002
@@ -0,0 +1,65 @@
+/*
+ * %W% %G%
+ *
+ * Copyright (c) 1998 Standard Performance Evaluation Corporation (SPEC)
+ *               All rights reserved.
+ * Copyright (c) 1997,1998 Sun Microsystems, Inc. All rights reserved.
+ *
+ * This source code is provided as is, without any express or implied warranty.
+ */
+
+package spec.io;
+
+/**
+ * This class implements a special form of PrintStream that is used by
+ * the benchmarks. The class vaieable spec.harness.Context.out is made
+ * to point to an instance of this class. The purpuse of the class is to
+ * record validity check information with the recorded output. This is done
+ * using one of nine integer values (0-8). 0 means the default validity checking
+ * is to be used and is what a Context.out.println() would employ. The numbers 
+ * 1 through 8 are used to set various valitity cheching rules. This class 
+ * implements a set of println() type methods that allow the text output to be 
+ * does so within the context of a certain validity cheching value. 
+ *
+ * These routines will output the valitity check value to the associated 
+ * OutputStream unchanged. This will cause them to be output as the character 
+ * values \u0000 to \u0008 these values are not normally used (the next one 
+ * \u0009 is) so this should not cause a problem. However this is checked for 
+ * in ValidityCheckOutputStream.
+ *
+ * @see ConsoleOutputStream
+ * @see ValidityCheckOutputStream
+ */ 
+public
+class PrintStream extends java.io.PrintStream {
+    /**
+     * The actual output stream. This is the same as 'out' in our superclass but
+     * kept here as well to avoid a lot of runtime casting.
+     */
+    
+    /**
+     * Creates a new PrintStream.
+     * @param out the output stream
+     */
+    public PrintStream(java.io.OutputStream out) {
+	super(out, false);
+    }
+    
+    /**
+     * Print a string in a validity context
+     * @param v the validity context value.
+     * @param s the data to be printed.
+     */    
+    synchronized public void print(char v, String s) {
+	super.print(s);
+    }
+    
+    /**
+     * Print a string in a validity context
+     * @param v the validity context value.
+     * @param s the data to be printed.
+     */    
+    synchronized public void println(char v, String s) {
+	super.println(s);
+    }    
+}
--- mpegaudio2/Main.java	Mon Dec  9 12:36:17 2002
+++ mpegaudio/Main.java	Mon Dec  9 12:34:26 2002
@@ -7,15 +7,15 @@
  * This source code is provided as is, without any express or implied warranty.
  */
 
-package spec.benchmarks._222_mpegaudio;
-import spec.harness.*;
+import spec.benchmarks._222_mpegaudio.*;
+//import spec.harness.*;
 
 
-public class Main implements SpecBenchmark {
+public class Main {
 
     static long runBenchmark( String[] args ) {
     
-	int speed = spec.harness.Context.getSpeed();    
+	int speed = 100;    
 	int iter  = 1;
 	String name = "track16.mp3";	
     
@@ -34,11 +34,11 @@
 	    args[0] = "input/"+name;
 	}
 	
-	spec.harness.Context.out.println( "MPEG Audio - Decoding " + args[0] + " " + iter + " time" + (iter > 1 ? "s" : "") );
+	System.out.println( "MPEG Audio - Decoding " + args[0] + " " + iter + " time" + (iter > 1 ? "s" : "") );
 	long startTime = System.currentTimeMillis();
 	
 	for( int i = 0 ; i < iter ; i++ ) {
-	    BenchDec.main( args );
+	    JavaDec.main( args );
 	}
 	
 	return System.currentTimeMillis() - startTime; 
diff -Nu mpegaudio2/postoutput.sh mpegaudio/postoutput.sh
--- mpegaudio2/postoutput.sh	Thu Jan  1 01:00:00 1970
+++ mpegaudio/postoutput.sh	Mon Dec  9 15:11:24 2002
@@ -0,0 +1 @@
+md5sum output.wav > mpegaudio.output
